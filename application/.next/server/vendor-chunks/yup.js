"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/yup";
exports.ids = ["vendor-chunks/yup"];
exports.modules = {

/***/ "(ssr)/../node_modules/yup/index.esm.js":
/*!****************************************!*\
  !*** ../node_modules/yup/index.esm.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArraySchema: () => (/* binding */ ArraySchema),\n/* harmony export */   BooleanSchema: () => (/* binding */ BooleanSchema),\n/* harmony export */   DateSchema: () => (/* binding */ DateSchema),\n/* harmony export */   MixedSchema: () => (/* binding */ MixedSchema),\n/* harmony export */   NumberSchema: () => (/* binding */ NumberSchema),\n/* harmony export */   ObjectSchema: () => (/* binding */ ObjectSchema),\n/* harmony export */   Schema: () => (/* binding */ Schema),\n/* harmony export */   StringSchema: () => (/* binding */ StringSchema),\n/* harmony export */   TupleSchema: () => (/* binding */ TupleSchema),\n/* harmony export */   ValidationError: () => (/* binding */ ValidationError),\n/* harmony export */   addMethod: () => (/* binding */ addMethod),\n/* harmony export */   array: () => (/* binding */ create$2),\n/* harmony export */   bool: () => (/* binding */ create$7),\n/* harmony export */   boolean: () => (/* binding */ create$7),\n/* harmony export */   date: () => (/* binding */ create$4),\n/* harmony export */   defaultLocale: () => (/* binding */ locale),\n/* harmony export */   getIn: () => (/* binding */ getIn),\n/* harmony export */   isSchema: () => (/* binding */ isSchema),\n/* harmony export */   lazy: () => (/* binding */ create),\n/* harmony export */   mixed: () => (/* binding */ create$8),\n/* harmony export */   number: () => (/* binding */ create$5),\n/* harmony export */   object: () => (/* binding */ create$3),\n/* harmony export */   printValue: () => (/* binding */ printValue),\n/* harmony export */   reach: () => (/* binding */ reach),\n/* harmony export */   ref: () => (/* binding */ create$9),\n/* harmony export */   setLocale: () => (/* binding */ setLocale),\n/* harmony export */   string: () => (/* binding */ create$6),\n/* harmony export */   tuple: () => (/* binding */ create$1)\n/* harmony export */ });\n/* harmony import */ var property_expr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! property-expr */ \"(ssr)/../node_modules/property-expr/index.js\");\n/* harmony import */ var property_expr__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(property_expr__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var tiny_case__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tiny-case */ \"(ssr)/../node_modules/tiny-case/index.js\");\n/* harmony import */ var tiny_case__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(tiny_case__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var toposort__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! toposort */ \"(ssr)/../node_modules/toposort/index.js\");\n/* harmony import */ var toposort__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(toposort__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\nconst toString = Object.prototype.toString;\nconst errorToString = Error.prototype.toString;\nconst regExpToString = RegExp.prototype.toString;\nconst symbolToString = typeof Symbol !== \"undefined\" ? Symbol.prototype.toString : ()=>\"\";\nconst SYMBOL_REGEXP = /^Symbol\\((.*)\\)(.*)$/;\nfunction printNumber(val) {\n    if (val != +val) return \"NaN\";\n    const isNegativeZero = val === 0 && 1 / val < 0;\n    return isNegativeZero ? \"-0\" : \"\" + val;\n}\nfunction printSimpleValue(val, quoteStrings = false) {\n    if (val == null || val === true || val === false) return \"\" + val;\n    const typeOf = typeof val;\n    if (typeOf === \"number\") return printNumber(val);\n    if (typeOf === \"string\") return quoteStrings ? `\"${val}\"` : val;\n    if (typeOf === \"function\") return \"[Function \" + (val.name || \"anonymous\") + \"]\";\n    if (typeOf === \"symbol\") return symbolToString.call(val).replace(SYMBOL_REGEXP, \"Symbol($1)\");\n    const tag = toString.call(val).slice(8, -1);\n    if (tag === \"Date\") return isNaN(val.getTime()) ? \"\" + val : val.toISOString(val);\n    if (tag === \"Error\" || val instanceof Error) return \"[\" + errorToString.call(val) + \"]\";\n    if (tag === \"RegExp\") return regExpToString.call(val);\n    return null;\n}\nfunction printValue(value, quoteStrings) {\n    let result = printSimpleValue(value, quoteStrings);\n    if (result !== null) return result;\n    return JSON.stringify(value, function(key, value) {\n        let result = printSimpleValue(this[key], quoteStrings);\n        if (result !== null) return result;\n        return value;\n    }, 2);\n}\nfunction toArray(value) {\n    return value == null ? [] : [].concat(value);\n}\nlet _Symbol$toStringTag, _Symbol$hasInstance, _Symbol$toStringTag2;\nlet strReg = /\\$\\{\\s*(\\w+)\\s*\\}/g;\n_Symbol$toStringTag = Symbol.toStringTag;\nclass ValidationErrorNoStack {\n    constructor(errorOrErrors, value, field, type){\n        this.name = void 0;\n        this.message = void 0;\n        this.value = void 0;\n        this.path = void 0;\n        this.type = void 0;\n        this.params = void 0;\n        this.errors = void 0;\n        this.inner = void 0;\n        this[_Symbol$toStringTag] = \"Error\";\n        this.name = \"ValidationError\";\n        this.value = value;\n        this.path = field;\n        this.type = type;\n        this.errors = [];\n        this.inner = [];\n        toArray(errorOrErrors).forEach((err)=>{\n            if (ValidationError.isError(err)) {\n                this.errors.push(...err.errors);\n                const innerErrors = err.inner.length ? err.inner : [\n                    err\n                ];\n                this.inner.push(...innerErrors);\n            } else {\n                this.errors.push(err);\n            }\n        });\n        this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0];\n    }\n}\n_Symbol$hasInstance = Symbol.hasInstance;\n_Symbol$toStringTag2 = Symbol.toStringTag;\nclass ValidationError extends Error {\n    static formatError(message, params) {\n        const path = params.label || params.path || \"this\";\n        if (path !== params.path) params = Object.assign({}, params, {\n            path\n        });\n        if (typeof message === \"string\") return message.replace(strReg, (_, key)=>printValue(params[key]));\n        if (typeof message === \"function\") return message(params);\n        return message;\n    }\n    static isError(err) {\n        return err && err.name === \"ValidationError\";\n    }\n    constructor(errorOrErrors, value, field, type, disableStack){\n        const errorNoStack = new ValidationErrorNoStack(errorOrErrors, value, field, type);\n        if (disableStack) {\n            return errorNoStack;\n        }\n        super();\n        this.value = void 0;\n        this.path = void 0;\n        this.type = void 0;\n        this.params = void 0;\n        this.errors = [];\n        this.inner = [];\n        this[_Symbol$toStringTag2] = \"Error\";\n        this.name = errorNoStack.name;\n        this.message = errorNoStack.message;\n        this.type = errorNoStack.type;\n        this.value = errorNoStack.value;\n        this.path = errorNoStack.path;\n        this.errors = errorNoStack.errors;\n        this.inner = errorNoStack.inner;\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, ValidationError);\n        }\n    }\n    static [_Symbol$hasInstance](inst) {\n        return ValidationErrorNoStack[Symbol.hasInstance](inst) || super[Symbol.hasInstance](inst);\n    }\n}\nlet mixed = {\n    default: \"${path} is invalid\",\n    required: \"${path} is a required field\",\n    defined: \"${path} must be defined\",\n    notNull: \"${path} cannot be null\",\n    oneOf: \"${path} must be one of the following values: ${values}\",\n    notOneOf: \"${path} must not be one of the following values: ${values}\",\n    notType: ({ path, type, value, originalValue })=>{\n        const castMsg = originalValue != null && originalValue !== value ? ` (cast from the value \\`${printValue(originalValue, true)}\\`).` : \".\";\n        return type !== \"mixed\" ? `${path} must be a \\`${type}\\` type, ` + `but the final value was: \\`${printValue(value, true)}\\`` + castMsg : `${path} must match the configured type. ` + `The validated value was: \\`${printValue(value, true)}\\`` + castMsg;\n    }\n};\nlet string = {\n    length: \"${path} must be exactly ${length} characters\",\n    min: \"${path} must be at least ${min} characters\",\n    max: \"${path} must be at most ${max} characters\",\n    matches: '${path} must match the following: \"${regex}\"',\n    email: \"${path} must be a valid email\",\n    url: \"${path} must be a valid URL\",\n    uuid: \"${path} must be a valid UUID\",\n    datetime: \"${path} must be a valid ISO date-time\",\n    datetime_precision: \"${path} must be a valid ISO date-time with a sub-second precision of exactly ${precision} digits\",\n    datetime_offset: '${path} must be a valid ISO date-time with UTC \"Z\" timezone',\n    trim: \"${path} must be a trimmed string\",\n    lowercase: \"${path} must be a lowercase string\",\n    uppercase: \"${path} must be a upper case string\"\n};\nlet number = {\n    min: \"${path} must be greater than or equal to ${min}\",\n    max: \"${path} must be less than or equal to ${max}\",\n    lessThan: \"${path} must be less than ${less}\",\n    moreThan: \"${path} must be greater than ${more}\",\n    positive: \"${path} must be a positive number\",\n    negative: \"${path} must be a negative number\",\n    integer: \"${path} must be an integer\"\n};\nlet date = {\n    min: \"${path} field must be later than ${min}\",\n    max: \"${path} field must be at earlier than ${max}\"\n};\nlet boolean = {\n    isValue: \"${path} field must be ${value}\"\n};\nlet object = {\n    noUnknown: \"${path} field has unspecified keys: ${unknown}\"\n};\nlet array = {\n    min: \"${path} field must have at least ${min} items\",\n    max: \"${path} field must have less than or equal to ${max} items\",\n    length: \"${path} must have ${length} items\"\n};\nlet tuple = {\n    notType: (params)=>{\n        const { path, value, spec } = params;\n        const typeLen = spec.types.length;\n        if (Array.isArray(value)) {\n            if (value.length < typeLen) return `${path} tuple value has too few items, expected a length of ${typeLen} but got ${value.length} for value: \\`${printValue(value, true)}\\``;\n            if (value.length > typeLen) return `${path} tuple value has too many items, expected a length of ${typeLen} but got ${value.length} for value: \\`${printValue(value, true)}\\``;\n        }\n        return ValidationError.formatError(mixed.notType, params);\n    }\n};\nvar locale = Object.assign(Object.create(null), {\n    mixed,\n    string,\n    number,\n    date,\n    object,\n    array,\n    boolean,\n    tuple\n});\nconst isSchema = (obj)=>obj && obj.__isYupSchema__;\nclass Condition {\n    static fromOptions(refs, config) {\n        if (!config.then && !config.otherwise) throw new TypeError(\"either `then:` or `otherwise:` is required for `when()` conditions\");\n        let { is, then, otherwise } = config;\n        let check = typeof is === \"function\" ? is : (...values)=>values.every((value)=>value === is);\n        return new Condition(refs, (values, schema)=>{\n            var _branch;\n            let branch = check(...values) ? then : otherwise;\n            return (_branch = branch == null ? void 0 : branch(schema)) != null ? _branch : schema;\n        });\n    }\n    constructor(refs, builder){\n        this.fn = void 0;\n        this.refs = refs;\n        this.refs = refs;\n        this.fn = builder;\n    }\n    resolve(base, options) {\n        let values = this.refs.map((ref)=>// TODO: ? operator here?\n            ref.getValue(options == null ? void 0 : options.value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context));\n        let schema = this.fn(values, base, options);\n        if (schema === undefined || // @ts-ignore this can be base\n        schema === base) {\n            return base;\n        }\n        if (!isSchema(schema)) throw new TypeError(\"conditions must return a schema object\");\n        return schema.resolve(options);\n    }\n}\nconst prefixes = {\n    context: \"$\",\n    value: \".\"\n};\nfunction create$9(key, options) {\n    return new Reference(key, options);\n}\nclass Reference {\n    constructor(key, options = {}){\n        this.key = void 0;\n        this.isContext = void 0;\n        this.isValue = void 0;\n        this.isSibling = void 0;\n        this.path = void 0;\n        this.getter = void 0;\n        this.map = void 0;\n        if (typeof key !== \"string\") throw new TypeError(\"ref must be a string, got: \" + key);\n        this.key = key.trim();\n        if (key === \"\") throw new TypeError(\"ref must be a non-empty string\");\n        this.isContext = this.key[0] === prefixes.context;\n        this.isValue = this.key[0] === prefixes.value;\n        this.isSibling = !this.isContext && !this.isValue;\n        let prefix = this.isContext ? prefixes.context : this.isValue ? prefixes.value : \"\";\n        this.path = this.key.slice(prefix.length);\n        this.getter = this.path && (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.getter)(this.path, true);\n        this.map = options.map;\n    }\n    getValue(value, parent, context) {\n        let result = this.isContext ? context : this.isValue ? value : parent;\n        if (this.getter) result = this.getter(result || {});\n        if (this.map) result = this.map(result);\n        return result;\n    }\n    /**\n   *\n   * @param {*} value\n   * @param {Object} options\n   * @param {Object=} options.context\n   * @param {Object=} options.parent\n   */ cast(value, options) {\n        return this.getValue(value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context);\n    }\n    resolve() {\n        return this;\n    }\n    describe() {\n        return {\n            type: \"ref\",\n            key: this.key\n        };\n    }\n    toString() {\n        return `Ref(${this.key})`;\n    }\n    static isRef(value) {\n        return value && value.__isYupRef;\n    }\n}\n// @ts-ignore\nReference.prototype.__isYupRef = true;\nconst isAbsent = (value)=>value == null;\nfunction createValidation(config) {\n    function validate({ value, path = \"\", options, originalValue, schema }, panic, next) {\n        const { name, test, params, message, skipAbsent } = config;\n        let { parent, context, abortEarly = schema.spec.abortEarly, disableStackTrace = schema.spec.disableStackTrace } = options;\n        function resolve(item) {\n            return Reference.isRef(item) ? item.getValue(value, parent, context) : item;\n        }\n        function createError(overrides = {}) {\n            const nextParams = Object.assign({\n                value,\n                originalValue,\n                label: schema.spec.label,\n                path: overrides.path || path,\n                spec: schema.spec,\n                disableStackTrace: overrides.disableStackTrace || disableStackTrace\n            }, params, overrides.params);\n            for (const key of Object.keys(nextParams))nextParams[key] = resolve(nextParams[key]);\n            const error = new ValidationError(ValidationError.formatError(overrides.message || message, nextParams), value, nextParams.path, overrides.type || name, nextParams.disableStackTrace);\n            error.params = nextParams;\n            return error;\n        }\n        const invalid = abortEarly ? panic : next;\n        let ctx = {\n            path,\n            parent,\n            type: name,\n            from: options.from,\n            createError,\n            resolve,\n            options,\n            originalValue,\n            schema\n        };\n        const handleResult = (validOrError)=>{\n            if (ValidationError.isError(validOrError)) invalid(validOrError);\n            else if (!validOrError) invalid(createError());\n            else next(null);\n        };\n        const handleError = (err)=>{\n            if (ValidationError.isError(err)) invalid(err);\n            else panic(err);\n        };\n        const shouldSkip = skipAbsent && isAbsent(value);\n        if (shouldSkip) {\n            return handleResult(true);\n        }\n        let result;\n        try {\n            var _result;\n            result = test.call(ctx, value, ctx);\n            if (typeof ((_result = result) == null ? void 0 : _result.then) === \"function\") {\n                if (options.sync) {\n                    throw new Error(`Validation test of type: \"${ctx.type}\" returned a Promise during a synchronous validate. ` + `This test will finish after the validate call has returned`);\n                }\n                return Promise.resolve(result).then(handleResult, handleError);\n            }\n        } catch (err) {\n            handleError(err);\n            return;\n        }\n        handleResult(result);\n    }\n    validate.OPTIONS = config;\n    return validate;\n}\nfunction getIn(schema, path, value, context = value) {\n    let parent, lastPart, lastPartDebug;\n    // root path: ''\n    if (!path) return {\n        parent,\n        parentPath: path,\n        schema\n    };\n    (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.forEach)(path, (_part, isBracket, isArray)=>{\n        let part = isBracket ? _part.slice(1, _part.length - 1) : _part;\n        schema = schema.resolve({\n            context,\n            parent,\n            value\n        });\n        let isTuple = schema.type === \"tuple\";\n        let idx = isArray ? parseInt(part, 10) : 0;\n        if (schema.innerType || isTuple) {\n            if (isTuple && !isArray) throw new Error(`Yup.reach cannot implicitly index into a tuple type. the path part \"${lastPartDebug}\" must contain an index to the tuple element, e.g. \"${lastPartDebug}[0]\"`);\n            if (value && idx >= value.length) {\n                throw new Error(`Yup.reach cannot resolve an array item at index: ${_part}, in the path: ${path}. ` + `because there is no value at that index. `);\n            }\n            parent = value;\n            value = value && value[idx];\n            schema = isTuple ? schema.spec.types[idx] : schema.innerType;\n        }\n        // sometimes the array index part of a path doesn't exist: \"nested.arr.child\"\n        // in these cases the current part is the next schema and should be processed\n        // in this iteration. For cases where the index signature is included this\n        // check will fail and we'll handle the `child` part on the next iteration like normal\n        if (!isArray) {\n            if (!schema.fields || !schema.fields[part]) throw new Error(`The schema does not contain the path: ${path}. ` + `(failed at: ${lastPartDebug} which is a type: \"${schema.type}\")`);\n            parent = value;\n            value = value && value[part];\n            schema = schema.fields[part];\n        }\n        lastPart = part;\n        lastPartDebug = isBracket ? \"[\" + _part + \"]\" : \".\" + _part;\n    });\n    return {\n        schema,\n        parent,\n        parentPath: lastPart\n    };\n}\nfunction reach(obj, path, value, context) {\n    return getIn(obj, path, value, context).schema;\n}\nclass ReferenceSet extends Set {\n    describe() {\n        const description = [];\n        for (const item of this.values()){\n            description.push(Reference.isRef(item) ? item.describe() : item);\n        }\n        return description;\n    }\n    resolveAll(resolve) {\n        let result = [];\n        for (const item of this.values()){\n            result.push(resolve(item));\n        }\n        return result;\n    }\n    clone() {\n        return new ReferenceSet(this.values());\n    }\n    merge(newItems, removeItems) {\n        const next = this.clone();\n        newItems.forEach((value)=>next.add(value));\n        removeItems.forEach((value)=>next.delete(value));\n        return next;\n    }\n}\n// tweaked from https://github.com/Kelin2025/nanoclone/blob/0abeb7635bda9b68ef2277093f76dbe3bf3948e1/src/index.js\nfunction clone(src, seen = new Map()) {\n    if (isSchema(src) || !src || typeof src !== \"object\") return src;\n    if (seen.has(src)) return seen.get(src);\n    let copy;\n    if (src instanceof Date) {\n        // Date\n        copy = new Date(src.getTime());\n        seen.set(src, copy);\n    } else if (src instanceof RegExp) {\n        // RegExp\n        copy = new RegExp(src);\n        seen.set(src, copy);\n    } else if (Array.isArray(src)) {\n        // Array\n        copy = new Array(src.length);\n        seen.set(src, copy);\n        for(let i = 0; i < src.length; i++)copy[i] = clone(src[i], seen);\n    } else if (src instanceof Map) {\n        // Map\n        copy = new Map();\n        seen.set(src, copy);\n        for (const [k, v] of src.entries())copy.set(k, clone(v, seen));\n    } else if (src instanceof Set) {\n        // Set\n        copy = new Set();\n        seen.set(src, copy);\n        for (const v of src)copy.add(clone(v, seen));\n    } else if (src instanceof Object) {\n        // Object\n        copy = {};\n        seen.set(src, copy);\n        for (const [k, v] of Object.entries(src))copy[k] = clone(v, seen);\n    } else {\n        throw Error(`Unable to clone ${src}`);\n    }\n    return copy;\n}\n// If `CustomSchemaMeta` isn't extended with any keys, we'll fall back to a\n// loose Record definition allowing free form usage.\nclass Schema {\n    constructor(options){\n        this.type = void 0;\n        this.deps = [];\n        this.tests = void 0;\n        this.transforms = void 0;\n        this.conditions = [];\n        this._mutate = void 0;\n        this.internalTests = {};\n        this._whitelist = new ReferenceSet();\n        this._blacklist = new ReferenceSet();\n        this.exclusiveTests = Object.create(null);\n        this._typeCheck = void 0;\n        this.spec = void 0;\n        this.tests = [];\n        this.transforms = [];\n        this.withMutation(()=>{\n            this.typeError(mixed.notType);\n        });\n        this.type = options.type;\n        this._typeCheck = options.check;\n        this.spec = Object.assign({\n            strip: false,\n            strict: false,\n            abortEarly: true,\n            recursive: true,\n            disableStackTrace: false,\n            nullable: false,\n            optional: true,\n            coerce: true\n        }, options == null ? void 0 : options.spec);\n        this.withMutation((s)=>{\n            s.nonNullable();\n        });\n    }\n    // TODO: remove\n    get _type() {\n        return this.type;\n    }\n    clone(spec) {\n        if (this._mutate) {\n            if (spec) Object.assign(this.spec, spec);\n            return this;\n        }\n        // if the nested value is a schema we can skip cloning, since\n        // they are already immutable\n        const next = Object.create(Object.getPrototypeOf(this));\n        // @ts-expect-error this is readonly\n        next.type = this.type;\n        next._typeCheck = this._typeCheck;\n        next._whitelist = this._whitelist.clone();\n        next._blacklist = this._blacklist.clone();\n        next.internalTests = Object.assign({}, this.internalTests);\n        next.exclusiveTests = Object.assign({}, this.exclusiveTests);\n        // @ts-expect-error this is readonly\n        next.deps = [\n            ...this.deps\n        ];\n        next.conditions = [\n            ...this.conditions\n        ];\n        next.tests = [\n            ...this.tests\n        ];\n        next.transforms = [\n            ...this.transforms\n        ];\n        next.spec = clone(Object.assign({}, this.spec, spec));\n        return next;\n    }\n    label(label) {\n        let next = this.clone();\n        next.spec.label = label;\n        return next;\n    }\n    meta(...args) {\n        if (args.length === 0) return this.spec.meta;\n        let next = this.clone();\n        next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);\n        return next;\n    }\n    withMutation(fn) {\n        let before = this._mutate;\n        this._mutate = true;\n        let result = fn(this);\n        this._mutate = before;\n        return result;\n    }\n    concat(schema) {\n        if (!schema || schema === this) return this;\n        if (schema.type !== this.type && this.type !== \"mixed\") throw new TypeError(`You cannot \\`concat()\\` schema's of different types: ${this.type} and ${schema.type}`);\n        let base = this;\n        let combined = schema.clone();\n        const mergedSpec = Object.assign({}, base.spec, combined.spec);\n        combined.spec = mergedSpec;\n        combined.internalTests = Object.assign({}, base.internalTests, combined.internalTests);\n        // manually merge the blacklist/whitelist (the other `schema` takes\n        // precedence in case of conflicts)\n        combined._whitelist = base._whitelist.merge(schema._whitelist, schema._blacklist);\n        combined._blacklist = base._blacklist.merge(schema._blacklist, schema._whitelist);\n        // start with the current tests\n        combined.tests = base.tests;\n        combined.exclusiveTests = base.exclusiveTests;\n        // manually add the new tests to ensure\n        // the deduping logic is consistent\n        combined.withMutation((next)=>{\n            schema.tests.forEach((fn)=>{\n                next.test(fn.OPTIONS);\n            });\n        });\n        combined.transforms = [\n            ...base.transforms,\n            ...combined.transforms\n        ];\n        return combined;\n    }\n    isType(v) {\n        if (v == null) {\n            if (this.spec.nullable && v === null) return true;\n            if (this.spec.optional && v === undefined) return true;\n            return false;\n        }\n        return this._typeCheck(v);\n    }\n    resolve(options) {\n        let schema = this;\n        if (schema.conditions.length) {\n            let conditions = schema.conditions;\n            schema = schema.clone();\n            schema.conditions = [];\n            schema = conditions.reduce((prevSchema, condition)=>condition.resolve(prevSchema, options), schema);\n            schema = schema.resolve(options);\n        }\n        return schema;\n    }\n    resolveOptions(options) {\n        var _options$strict, _options$abortEarly, _options$recursive, _options$disableStack;\n        return Object.assign({}, options, {\n            from: options.from || [],\n            strict: (_options$strict = options.strict) != null ? _options$strict : this.spec.strict,\n            abortEarly: (_options$abortEarly = options.abortEarly) != null ? _options$abortEarly : this.spec.abortEarly,\n            recursive: (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive,\n            disableStackTrace: (_options$disableStack = options.disableStackTrace) != null ? _options$disableStack : this.spec.disableStackTrace\n        });\n    }\n    /**\n   * Run the configured transform pipeline over an input value.\n   */ cast(value, options = {}) {\n        let resolvedSchema = this.resolve(Object.assign({\n            value\n        }, options));\n        let allowOptionality = options.assert === \"ignore-optionality\";\n        let result = resolvedSchema._cast(value, options);\n        if (options.assert !== false && !resolvedSchema.isType(result)) {\n            if (allowOptionality && isAbsent(result)) {\n                return result;\n            }\n            let formattedValue = printValue(value);\n            let formattedResult = printValue(result);\n            throw new TypeError(`The value of ${options.path || \"field\"} could not be cast to a value ` + `that satisfies the schema type: \"${resolvedSchema.type}\". \\n\\n` + `attempted value: ${formattedValue} \\n` + (formattedResult !== formattedValue ? `result of cast: ${formattedResult}` : \"\"));\n        }\n        return result;\n    }\n    _cast(rawValue, options) {\n        let value = rawValue === undefined ? rawValue : this.transforms.reduce((prevValue, fn)=>fn.call(this, prevValue, rawValue, this), rawValue);\n        if (value === undefined) {\n            value = this.getDefault(options);\n        }\n        return value;\n    }\n    _validate(_value, options = {}, panic, next) {\n        let { path, originalValue = _value, strict = this.spec.strict } = options;\n        let value = _value;\n        if (!strict) {\n            value = this._cast(value, Object.assign({\n                assert: false\n            }, options));\n        }\n        let initialTests = [];\n        for (let test of Object.values(this.internalTests)){\n            if (test) initialTests.push(test);\n        }\n        this.runTests({\n            path,\n            value,\n            originalValue,\n            options,\n            tests: initialTests\n        }, panic, (initialErrors)=>{\n            // even if we aren't ending early we can't proceed further if the types aren't correct\n            if (initialErrors.length) {\n                return next(initialErrors, value);\n            }\n            this.runTests({\n                path,\n                value,\n                originalValue,\n                options,\n                tests: this.tests\n            }, panic, next);\n        });\n    }\n    /**\n   * Executes a set of validations, either schema, produced Tests or a nested\n   * schema validate result.\n   */ runTests(runOptions, panic, next) {\n        let fired = false;\n        let { tests, value, originalValue, path, options } = runOptions;\n        let panicOnce = (arg)=>{\n            if (fired) return;\n            fired = true;\n            panic(arg, value);\n        };\n        let nextOnce = (arg)=>{\n            if (fired) return;\n            fired = true;\n            next(arg, value);\n        };\n        let count = tests.length;\n        let nestedErrors = [];\n        if (!count) return nextOnce([]);\n        let args = {\n            value,\n            originalValue,\n            path,\n            options,\n            schema: this\n        };\n        for(let i = 0; i < tests.length; i++){\n            const test = tests[i];\n            test(args, panicOnce, function finishTestRun(err) {\n                if (err) {\n                    Array.isArray(err) ? nestedErrors.push(...err) : nestedErrors.push(err);\n                }\n                if (--count <= 0) {\n                    nextOnce(nestedErrors);\n                }\n            });\n        }\n    }\n    asNestedTest({ key, index, parent, parentPath, originalParent, options }) {\n        const k = key != null ? key : index;\n        if (k == null) {\n            throw TypeError(\"Must include `key` or `index` for nested validations\");\n        }\n        const isIndex = typeof k === \"number\";\n        let value = parent[k];\n        const testOptions = Object.assign({}, options, {\n            // Nested validations fields are always strict:\n            //    1. parent isn't strict so the casting will also have cast inner values\n            //    2. parent is strict in which case the nested values weren't cast either\n            strict: true,\n            parent,\n            value,\n            originalValue: originalParent[k],\n            // FIXME: tests depend on `index` being passed around deeply,\n            //   we should not let the options.key/index bleed through\n            key: undefined,\n            // index: undefined,\n            [isIndex ? \"index\" : \"key\"]: k,\n            path: isIndex || k.includes(\".\") ? `${parentPath || \"\"}[${isIndex ? k : `\"${k}\"`}]` : (parentPath ? `${parentPath}.` : \"\") + key\n        });\n        return (_, panic, next)=>this.resolve(testOptions)._validate(value, testOptions, panic, next);\n    }\n    validate(value, options) {\n        var _options$disableStack2;\n        let schema = this.resolve(Object.assign({}, options, {\n            value\n        }));\n        let disableStackTrace = (_options$disableStack2 = options == null ? void 0 : options.disableStackTrace) != null ? _options$disableStack2 : schema.spec.disableStackTrace;\n        return new Promise((resolve, reject)=>schema._validate(value, options, (error, parsed)=>{\n                if (ValidationError.isError(error)) error.value = parsed;\n                reject(error);\n            }, (errors, validated)=>{\n                if (errors.length) reject(new ValidationError(errors, validated, undefined, undefined, disableStackTrace));\n                else resolve(validated);\n            }));\n    }\n    validateSync(value, options) {\n        var _options$disableStack3;\n        let schema = this.resolve(Object.assign({}, options, {\n            value\n        }));\n        let result;\n        let disableStackTrace = (_options$disableStack3 = options == null ? void 0 : options.disableStackTrace) != null ? _options$disableStack3 : schema.spec.disableStackTrace;\n        schema._validate(value, Object.assign({}, options, {\n            sync: true\n        }), (error, parsed)=>{\n            if (ValidationError.isError(error)) error.value = parsed;\n            throw error;\n        }, (errors, validated)=>{\n            if (errors.length) throw new ValidationError(errors, value, undefined, undefined, disableStackTrace);\n            result = validated;\n        });\n        return result;\n    }\n    isValid(value, options) {\n        return this.validate(value, options).then(()=>true, (err)=>{\n            if (ValidationError.isError(err)) return false;\n            throw err;\n        });\n    }\n    isValidSync(value, options) {\n        try {\n            this.validateSync(value, options);\n            return true;\n        } catch (err) {\n            if (ValidationError.isError(err)) return false;\n            throw err;\n        }\n    }\n    _getDefault(options) {\n        let defaultValue = this.spec.default;\n        if (defaultValue == null) {\n            return defaultValue;\n        }\n        return typeof defaultValue === \"function\" ? defaultValue.call(this, options) : clone(defaultValue);\n    }\n    getDefault(options) {\n        let schema = this.resolve(options || {});\n        return schema._getDefault(options);\n    }\n    default(def) {\n        if (arguments.length === 0) {\n            return this._getDefault();\n        }\n        let next = this.clone({\n            default: def\n        });\n        return next;\n    }\n    strict(isStrict = true) {\n        return this.clone({\n            strict: isStrict\n        });\n    }\n    nullability(nullable, message) {\n        const next = this.clone({\n            nullable\n        });\n        next.internalTests.nullable = createValidation({\n            message,\n            name: \"nullable\",\n            test (value) {\n                return value === null ? this.schema.spec.nullable : true;\n            }\n        });\n        return next;\n    }\n    optionality(optional, message) {\n        const next = this.clone({\n            optional\n        });\n        next.internalTests.optionality = createValidation({\n            message,\n            name: \"optionality\",\n            test (value) {\n                return value === undefined ? this.schema.spec.optional : true;\n            }\n        });\n        return next;\n    }\n    optional() {\n        return this.optionality(true);\n    }\n    defined(message = mixed.defined) {\n        return this.optionality(false, message);\n    }\n    nullable() {\n        return this.nullability(true);\n    }\n    nonNullable(message = mixed.notNull) {\n        return this.nullability(false, message);\n    }\n    required(message = mixed.required) {\n        return this.clone().withMutation((next)=>next.nonNullable(message).defined(message));\n    }\n    notRequired() {\n        return this.clone().withMutation((next)=>next.nullable().optional());\n    }\n    transform(fn) {\n        let next = this.clone();\n        next.transforms.push(fn);\n        return next;\n    }\n    /**\n   * Adds a test function to the schema's queue of tests.\n   * tests can be exclusive or non-exclusive.\n   *\n   * - exclusive tests, will replace any existing tests of the same name.\n   * - non-exclusive: can be stacked\n   *\n   * If a non-exclusive test is added to a schema with an exclusive test of the same name\n   * the exclusive test is removed and further tests of the same name will be stacked.\n   *\n   * If an exclusive test is added to a schema with non-exclusive tests of the same name\n   * the previous tests are removed and further tests of the same name will replace each other.\n   */ test(...args) {\n        let opts;\n        if (args.length === 1) {\n            if (typeof args[0] === \"function\") {\n                opts = {\n                    test: args[0]\n                };\n            } else {\n                opts = args[0];\n            }\n        } else if (args.length === 2) {\n            opts = {\n                name: args[0],\n                test: args[1]\n            };\n        } else {\n            opts = {\n                name: args[0],\n                message: args[1],\n                test: args[2]\n            };\n        }\n        if (opts.message === undefined) opts.message = mixed.default;\n        if (typeof opts.test !== \"function\") throw new TypeError(\"`test` is a required parameters\");\n        let next = this.clone();\n        let validate = createValidation(opts);\n        let isExclusive = opts.exclusive || opts.name && next.exclusiveTests[opts.name] === true;\n        if (opts.exclusive) {\n            if (!opts.name) throw new TypeError(\"Exclusive tests must provide a unique `name` identifying the test\");\n        }\n        if (opts.name) next.exclusiveTests[opts.name] = !!opts.exclusive;\n        next.tests = next.tests.filter((fn)=>{\n            if (fn.OPTIONS.name === opts.name) {\n                if (isExclusive) return false;\n                if (fn.OPTIONS.test === validate.OPTIONS.test) return false;\n            }\n            return true;\n        });\n        next.tests.push(validate);\n        return next;\n    }\n    when(keys, options) {\n        if (!Array.isArray(keys) && typeof keys !== \"string\") {\n            options = keys;\n            keys = \".\";\n        }\n        let next = this.clone();\n        let deps = toArray(keys).map((key)=>new Reference(key));\n        deps.forEach((dep)=>{\n            // @ts-ignore readonly array\n            if (dep.isSibling) next.deps.push(dep.key);\n        });\n        next.conditions.push(typeof options === \"function\" ? new Condition(deps, options) : Condition.fromOptions(deps, options));\n        return next;\n    }\n    typeError(message) {\n        let next = this.clone();\n        next.internalTests.typeError = createValidation({\n            message,\n            name: \"typeError\",\n            skipAbsent: true,\n            test (value) {\n                if (!this.schema._typeCheck(value)) return this.createError({\n                    params: {\n                        type: this.schema.type\n                    }\n                });\n                return true;\n            }\n        });\n        return next;\n    }\n    oneOf(enums, message = mixed.oneOf) {\n        let next = this.clone();\n        enums.forEach((val)=>{\n            next._whitelist.add(val);\n            next._blacklist.delete(val);\n        });\n        next.internalTests.whiteList = createValidation({\n            message,\n            name: \"oneOf\",\n            skipAbsent: true,\n            test (value) {\n                let valids = this.schema._whitelist;\n                let resolved = valids.resolveAll(this.resolve);\n                return resolved.includes(value) ? true : this.createError({\n                    params: {\n                        values: Array.from(valids).join(\", \"),\n                        resolved\n                    }\n                });\n            }\n        });\n        return next;\n    }\n    notOneOf(enums, message = mixed.notOneOf) {\n        let next = this.clone();\n        enums.forEach((val)=>{\n            next._blacklist.add(val);\n            next._whitelist.delete(val);\n        });\n        next.internalTests.blacklist = createValidation({\n            message,\n            name: \"notOneOf\",\n            test (value) {\n                let invalids = this.schema._blacklist;\n                let resolved = invalids.resolveAll(this.resolve);\n                if (resolved.includes(value)) return this.createError({\n                    params: {\n                        values: Array.from(invalids).join(\", \"),\n                        resolved\n                    }\n                });\n                return true;\n            }\n        });\n        return next;\n    }\n    strip(strip = true) {\n        let next = this.clone();\n        next.spec.strip = strip;\n        return next;\n    }\n    /**\n   * Return a serialized description of the schema including validations, flags, types etc.\n   *\n   * @param options Provide any needed context for resolving runtime schema alterations (lazy, when conditions, etc).\n   */ describe(options) {\n        const next = (options ? this.resolve(options) : this).clone();\n        const { label, meta, optional, nullable } = next.spec;\n        const description = {\n            meta,\n            label,\n            optional,\n            nullable,\n            default: next.getDefault(options),\n            type: next.type,\n            oneOf: next._whitelist.describe(),\n            notOneOf: next._blacklist.describe(),\n            tests: next.tests.map((fn)=>({\n                    name: fn.OPTIONS.name,\n                    params: fn.OPTIONS.params\n                })).filter((n, idx, list)=>list.findIndex((c)=>c.name === n.name) === idx)\n        };\n        return description;\n    }\n}\n// @ts-expect-error\nSchema.prototype.__isYupSchema__ = true;\nfor (const method of [\n    \"validate\",\n    \"validateSync\"\n])Schema.prototype[`${method}At`] = function(path, value, options = {}) {\n    const { parent, parentPath, schema } = getIn(this, path, value, options.context);\n    return schema[method](parent && parent[parentPath], Object.assign({}, options, {\n        parent,\n        path\n    }));\n};\nfor (const alias of [\n    \"equals\",\n    \"is\"\n])Schema.prototype[alias] = Schema.prototype.oneOf;\nfor (const alias of [\n    \"not\",\n    \"nope\"\n])Schema.prototype[alias] = Schema.prototype.notOneOf;\nconst returnsTrue = ()=>true;\nfunction create$8(spec) {\n    return new MixedSchema(spec);\n}\nclass MixedSchema extends Schema {\n    constructor(spec){\n        super(typeof spec === \"function\" ? {\n            type: \"mixed\",\n            check: spec\n        } : Object.assign({\n            type: \"mixed\",\n            check: returnsTrue\n        }, spec));\n    }\n}\ncreate$8.prototype = MixedSchema.prototype;\nfunction create$7() {\n    return new BooleanSchema();\n}\nclass BooleanSchema extends Schema {\n    constructor(){\n        super({\n            type: \"boolean\",\n            check (v) {\n                if (v instanceof Boolean) v = v.valueOf();\n                return typeof v === \"boolean\";\n            }\n        });\n        this.withMutation(()=>{\n            this.transform((value, _raw, ctx)=>{\n                if (ctx.spec.coerce && !ctx.isType(value)) {\n                    if (/^(true|1)$/i.test(String(value))) return true;\n                    if (/^(false|0)$/i.test(String(value))) return false;\n                }\n                return value;\n            });\n        });\n    }\n    isTrue(message = boolean.isValue) {\n        return this.test({\n            message,\n            name: \"is-value\",\n            exclusive: true,\n            params: {\n                value: \"true\"\n            },\n            test (value) {\n                return isAbsent(value) || value === true;\n            }\n        });\n    }\n    isFalse(message = boolean.isValue) {\n        return this.test({\n            message,\n            name: \"is-value\",\n            exclusive: true,\n            params: {\n                value: \"false\"\n            },\n            test (value) {\n                return isAbsent(value) || value === false;\n            }\n        });\n    }\n    default(def) {\n        return super.default(def);\n    }\n    defined(msg) {\n        return super.defined(msg);\n    }\n    optional() {\n        return super.optional();\n    }\n    required(msg) {\n        return super.required(msg);\n    }\n    notRequired() {\n        return super.notRequired();\n    }\n    nullable() {\n        return super.nullable();\n    }\n    nonNullable(msg) {\n        return super.nonNullable(msg);\n    }\n    strip(v) {\n        return super.strip(v);\n    }\n}\ncreate$7.prototype = BooleanSchema.prototype;\n/**\n * This file is a modified version of the file from the following repository:\n * Date.parse with progressive enhancement for ISO 8601 <https://github.com/csnover/js-iso8601>\n * NON-CONFORMANT EDITION.\n * © 2011 Colin Snover <http://zetafleet.com>\n * Released under MIT license.\n */ // prettier-ignore\n//                1 YYYY                2 MM        3 DD              4 HH     5 mm        6 ss           7 msec         8 Z 9 ±   10 tzHH    11 tzmm\nconst isoReg = /^(\\d{4}|[+-]\\d{6})(?:-?(\\d{2})(?:-?(\\d{2}))?)?(?:[ T]?(\\d{2}):?(\\d{2})(?::?(\\d{2})(?:[,.](\\d{1,}))?)?(?:(Z)|([+-])(\\d{2})(?::?(\\d{2}))?)?)?$/;\nfunction parseIsoDate(date) {\n    const struct = parseDateStruct(date);\n    if (!struct) return Date.parse ? Date.parse(date) : Number.NaN;\n    // timestamps without timezone identifiers should be considered local time\n    if (struct.z === undefined && struct.plusMinus === undefined) {\n        return new Date(struct.year, struct.month, struct.day, struct.hour, struct.minute, struct.second, struct.millisecond).valueOf();\n    }\n    let totalMinutesOffset = 0;\n    if (struct.z !== \"Z\" && struct.plusMinus !== undefined) {\n        totalMinutesOffset = struct.hourOffset * 60 + struct.minuteOffset;\n        if (struct.plusMinus === \"+\") totalMinutesOffset = 0 - totalMinutesOffset;\n    }\n    return Date.UTC(struct.year, struct.month, struct.day, struct.hour, struct.minute + totalMinutesOffset, struct.second, struct.millisecond);\n}\nfunction parseDateStruct(date) {\n    var _regexResult$7$length, _regexResult$;\n    const regexResult = isoReg.exec(date);\n    if (!regexResult) return null;\n    // use of toNumber() avoids NaN timestamps caused by “undefined”\n    // values being passed to Date constructor\n    return {\n        year: toNumber(regexResult[1]),\n        month: toNumber(regexResult[2], 1) - 1,\n        day: toNumber(regexResult[3], 1),\n        hour: toNumber(regexResult[4]),\n        minute: toNumber(regexResult[5]),\n        second: toNumber(regexResult[6]),\n        millisecond: regexResult[7] ? // allow arbitrary sub-second precision beyond milliseconds\n        toNumber(regexResult[7].substring(0, 3)) : 0,\n        precision: (_regexResult$7$length = (_regexResult$ = regexResult[7]) == null ? void 0 : _regexResult$.length) != null ? _regexResult$7$length : undefined,\n        z: regexResult[8] || undefined,\n        plusMinus: regexResult[9] || undefined,\n        hourOffset: toNumber(regexResult[10]),\n        minuteOffset: toNumber(regexResult[11])\n    };\n}\nfunction toNumber(str, defaultValue = 0) {\n    return Number(str) || defaultValue;\n}\n// Taken from HTML spec: https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address\nlet rEmail = // eslint-disable-next-line\n/^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\nlet rUrl = // eslint-disable-next-line\n/^((https?|ftp):)?\\/\\/(((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:)*@)?(((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5]))|((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?)(:\\d*)?)(\\/((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)+(\\/(([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)*)*)?)?(\\?((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|[\\uE000-\\uF8FF]|\\/|\\?)*)?(\\#((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|\\/|\\?)*)?$/i;\n// eslint-disable-next-line\nlet rUUID = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;\nlet yearMonthDay = \"^\\\\d{4}-\\\\d{2}-\\\\d{2}\";\nlet hourMinuteSecond = \"\\\\d{2}:\\\\d{2}:\\\\d{2}\";\nlet zOrOffset = \"(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)\";\nlet rIsoDateTime = new RegExp(`${yearMonthDay}T${hourMinuteSecond}(\\\\.\\\\d+)?${zOrOffset}$`);\nlet isTrimmed = (value)=>isAbsent(value) || value === value.trim();\nlet objStringTag = ({}).toString();\nfunction create$6() {\n    return new StringSchema();\n}\nclass StringSchema extends Schema {\n    constructor(){\n        super({\n            type: \"string\",\n            check (value) {\n                if (value instanceof String) value = value.valueOf();\n                return typeof value === \"string\";\n            }\n        });\n        this.withMutation(()=>{\n            this.transform((value, _raw, ctx)=>{\n                if (!ctx.spec.coerce || ctx.isType(value)) return value;\n                // don't ever convert arrays\n                if (Array.isArray(value)) return value;\n                const strValue = value != null && value.toString ? value.toString() : value;\n                // no one wants plain objects converted to [Object object]\n                if (strValue === objStringTag) return value;\n                return strValue;\n            });\n        });\n    }\n    required(message) {\n        return super.required(message).withMutation((schema)=>schema.test({\n                message: message || mixed.required,\n                name: \"required\",\n                skipAbsent: true,\n                test: (value)=>!!value.length\n            }));\n    }\n    notRequired() {\n        return super.notRequired().withMutation((schema)=>{\n            schema.tests = schema.tests.filter((t)=>t.OPTIONS.name !== \"required\");\n            return schema;\n        });\n    }\n    length(length, message = string.length) {\n        return this.test({\n            message,\n            name: \"length\",\n            exclusive: true,\n            params: {\n                length\n            },\n            skipAbsent: true,\n            test (value) {\n                return value.length === this.resolve(length);\n            }\n        });\n    }\n    min(min, message = string.min) {\n        return this.test({\n            message,\n            name: \"min\",\n            exclusive: true,\n            params: {\n                min\n            },\n            skipAbsent: true,\n            test (value) {\n                return value.length >= this.resolve(min);\n            }\n        });\n    }\n    max(max, message = string.max) {\n        return this.test({\n            name: \"max\",\n            exclusive: true,\n            message,\n            params: {\n                max\n            },\n            skipAbsent: true,\n            test (value) {\n                return value.length <= this.resolve(max);\n            }\n        });\n    }\n    matches(regex, options) {\n        let excludeEmptyString = false;\n        let message;\n        let name;\n        if (options) {\n            if (typeof options === \"object\") {\n                ({ excludeEmptyString = false, message, name } = options);\n            } else {\n                message = options;\n            }\n        }\n        return this.test({\n            name: name || \"matches\",\n            message: message || string.matches,\n            params: {\n                regex\n            },\n            skipAbsent: true,\n            test: (value)=>value === \"\" && excludeEmptyString || value.search(regex) !== -1\n        });\n    }\n    email(message = string.email) {\n        return this.matches(rEmail, {\n            name: \"email\",\n            message,\n            excludeEmptyString: true\n        });\n    }\n    url(message = string.url) {\n        return this.matches(rUrl, {\n            name: \"url\",\n            message,\n            excludeEmptyString: true\n        });\n    }\n    uuid(message = string.uuid) {\n        return this.matches(rUUID, {\n            name: \"uuid\",\n            message,\n            excludeEmptyString: false\n        });\n    }\n    datetime(options) {\n        let message = \"\";\n        let allowOffset;\n        let precision;\n        if (options) {\n            if (typeof options === \"object\") {\n                ({ message = \"\", allowOffset = false, precision = undefined } = options);\n            } else {\n                message = options;\n            }\n        }\n        return this.matches(rIsoDateTime, {\n            name: \"datetime\",\n            message: message || string.datetime,\n            excludeEmptyString: true\n        }).test({\n            name: \"datetime_offset\",\n            message: message || string.datetime_offset,\n            params: {\n                allowOffset\n            },\n            skipAbsent: true,\n            test: (value)=>{\n                if (!value || allowOffset) return true;\n                const struct = parseDateStruct(value);\n                if (!struct) return false;\n                return !!struct.z;\n            }\n        }).test({\n            name: \"datetime_precision\",\n            message: message || string.datetime_precision,\n            params: {\n                precision\n            },\n            skipAbsent: true,\n            test: (value)=>{\n                if (!value || precision == undefined) return true;\n                const struct = parseDateStruct(value);\n                if (!struct) return false;\n                return struct.precision === precision;\n            }\n        });\n    }\n    //-- transforms --\n    ensure() {\n        return this.default(\"\").transform((val)=>val === null ? \"\" : val);\n    }\n    trim(message = string.trim) {\n        return this.transform((val)=>val != null ? val.trim() : val).test({\n            message,\n            name: \"trim\",\n            test: isTrimmed\n        });\n    }\n    lowercase(message = string.lowercase) {\n        return this.transform((value)=>!isAbsent(value) ? value.toLowerCase() : value).test({\n            message,\n            name: \"string_case\",\n            exclusive: true,\n            skipAbsent: true,\n            test: (value)=>isAbsent(value) || value === value.toLowerCase()\n        });\n    }\n    uppercase(message = string.uppercase) {\n        return this.transform((value)=>!isAbsent(value) ? value.toUpperCase() : value).test({\n            message,\n            name: \"string_case\",\n            exclusive: true,\n            skipAbsent: true,\n            test: (value)=>isAbsent(value) || value === value.toUpperCase()\n        });\n    }\n}\ncreate$6.prototype = StringSchema.prototype;\n//\n// String Interfaces\n//\nlet isNaN$1 = (value)=>value != +value;\nfunction create$5() {\n    return new NumberSchema();\n}\nclass NumberSchema extends Schema {\n    constructor(){\n        super({\n            type: \"number\",\n            check (value) {\n                if (value instanceof Number) value = value.valueOf();\n                return typeof value === \"number\" && !isNaN$1(value);\n            }\n        });\n        this.withMutation(()=>{\n            this.transform((value, _raw, ctx)=>{\n                if (!ctx.spec.coerce) return value;\n                let parsed = value;\n                if (typeof parsed === \"string\") {\n                    parsed = parsed.replace(/\\s/g, \"\");\n                    if (parsed === \"\") return NaN;\n                    // don't use parseFloat to avoid positives on alpha-numeric strings\n                    parsed = +parsed;\n                }\n                // null -> NaN isn't useful; treat all nulls as null and let it fail on\n                // nullability check vs TypeErrors\n                if (ctx.isType(parsed) || parsed === null) return parsed;\n                return parseFloat(parsed);\n            });\n        });\n    }\n    min(min, message = number.min) {\n        return this.test({\n            message,\n            name: \"min\",\n            exclusive: true,\n            params: {\n                min\n            },\n            skipAbsent: true,\n            test (value) {\n                return value >= this.resolve(min);\n            }\n        });\n    }\n    max(max, message = number.max) {\n        return this.test({\n            message,\n            name: \"max\",\n            exclusive: true,\n            params: {\n                max\n            },\n            skipAbsent: true,\n            test (value) {\n                return value <= this.resolve(max);\n            }\n        });\n    }\n    lessThan(less, message = number.lessThan) {\n        return this.test({\n            message,\n            name: \"max\",\n            exclusive: true,\n            params: {\n                less\n            },\n            skipAbsent: true,\n            test (value) {\n                return value < this.resolve(less);\n            }\n        });\n    }\n    moreThan(more, message = number.moreThan) {\n        return this.test({\n            message,\n            name: \"min\",\n            exclusive: true,\n            params: {\n                more\n            },\n            skipAbsent: true,\n            test (value) {\n                return value > this.resolve(more);\n            }\n        });\n    }\n    positive(msg = number.positive) {\n        return this.moreThan(0, msg);\n    }\n    negative(msg = number.negative) {\n        return this.lessThan(0, msg);\n    }\n    integer(message = number.integer) {\n        return this.test({\n            name: \"integer\",\n            message,\n            skipAbsent: true,\n            test: (val)=>Number.isInteger(val)\n        });\n    }\n    truncate() {\n        return this.transform((value)=>!isAbsent(value) ? value | 0 : value);\n    }\n    round(method) {\n        var _method;\n        let avail = [\n            \"ceil\",\n            \"floor\",\n            \"round\",\n            \"trunc\"\n        ];\n        method = ((_method = method) == null ? void 0 : _method.toLowerCase()) || \"round\";\n        // this exists for symemtry with the new Math.trunc\n        if (method === \"trunc\") return this.truncate();\n        if (avail.indexOf(method.toLowerCase()) === -1) throw new TypeError(\"Only valid options for round() are: \" + avail.join(\", \"));\n        return this.transform((value)=>!isAbsent(value) ? Math[method](value) : value);\n    }\n}\ncreate$5.prototype = NumberSchema.prototype;\n//\n// Number Interfaces\n//\nlet invalidDate = new Date(\"\");\nlet isDate = (obj)=>Object.prototype.toString.call(obj) === \"[object Date]\";\nfunction create$4() {\n    return new DateSchema();\n}\nclass DateSchema extends Schema {\n    constructor(){\n        super({\n            type: \"date\",\n            check (v) {\n                return isDate(v) && !isNaN(v.getTime());\n            }\n        });\n        this.withMutation(()=>{\n            this.transform((value, _raw, ctx)=>{\n                // null -> InvalidDate isn't useful; treat all nulls as null and let it fail on\n                // nullability check vs TypeErrors\n                if (!ctx.spec.coerce || ctx.isType(value) || value === null) return value;\n                value = parseIsoDate(value);\n                // 0 is a valid timestamp equivalent to 1970-01-01T00:00:00Z(unix epoch) or before.\n                return !isNaN(value) ? new Date(value) : DateSchema.INVALID_DATE;\n            });\n        });\n    }\n    prepareParam(ref, name) {\n        let param;\n        if (!Reference.isRef(ref)) {\n            let cast = this.cast(ref);\n            if (!this._typeCheck(cast)) throw new TypeError(`\\`${name}\\` must be a Date or a value that can be \\`cast()\\` to a Date`);\n            param = cast;\n        } else {\n            param = ref;\n        }\n        return param;\n    }\n    min(min, message = date.min) {\n        let limit = this.prepareParam(min, \"min\");\n        return this.test({\n            message,\n            name: \"min\",\n            exclusive: true,\n            params: {\n                min\n            },\n            skipAbsent: true,\n            test (value) {\n                return value >= this.resolve(limit);\n            }\n        });\n    }\n    max(max, message = date.max) {\n        let limit = this.prepareParam(max, \"max\");\n        return this.test({\n            message,\n            name: \"max\",\n            exclusive: true,\n            params: {\n                max\n            },\n            skipAbsent: true,\n            test (value) {\n                return value <= this.resolve(limit);\n            }\n        });\n    }\n}\nDateSchema.INVALID_DATE = invalidDate;\ncreate$4.prototype = DateSchema.prototype;\ncreate$4.INVALID_DATE = invalidDate;\n// @ts-expect-error\nfunction sortFields(fields, excludedEdges = []) {\n    let edges = [];\n    let nodes = new Set();\n    let excludes = new Set(excludedEdges.map(([a, b])=>`${a}-${b}`));\n    function addNode(depPath, key) {\n        let node = (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.split)(depPath)[0];\n        nodes.add(node);\n        if (!excludes.has(`${key}-${node}`)) edges.push([\n            key,\n            node\n        ]);\n    }\n    for (const key of Object.keys(fields)){\n        let value = fields[key];\n        nodes.add(key);\n        if (Reference.isRef(value) && value.isSibling) addNode(value.path, key);\n        else if (isSchema(value) && \"deps\" in value) value.deps.forEach((path)=>addNode(path, key));\n    }\n    return toposort__WEBPACK_IMPORTED_MODULE_2___default().array(Array.from(nodes), edges).reverse();\n}\nfunction findIndex(arr, err) {\n    let idx = Infinity;\n    arr.some((key, ii)=>{\n        var _err$path;\n        if ((_err$path = err.path) != null && _err$path.includes(key)) {\n            idx = ii;\n            return true;\n        }\n    });\n    return idx;\n}\nfunction sortByKeyOrder(keys) {\n    return (a, b)=>{\n        return findIndex(keys, a) - findIndex(keys, b);\n    };\n}\nconst parseJson = (value, _, ctx)=>{\n    if (typeof value !== \"string\") {\n        return value;\n    }\n    let parsed = value;\n    try {\n        parsed = JSON.parse(value);\n    } catch (err) {\n    /* */ }\n    return ctx.isType(parsed) ? parsed : value;\n};\n// @ts-ignore\nfunction deepPartial(schema) {\n    if (\"fields\" in schema) {\n        const partial = {};\n        for (const [key, fieldSchema] of Object.entries(schema.fields)){\n            partial[key] = deepPartial(fieldSchema);\n        }\n        return schema.setFields(partial);\n    }\n    if (schema.type === \"array\") {\n        const nextArray = schema.optional();\n        if (nextArray.innerType) nextArray.innerType = deepPartial(nextArray.innerType);\n        return nextArray;\n    }\n    if (schema.type === \"tuple\") {\n        return schema.optional().clone({\n            types: schema.spec.types.map(deepPartial)\n        });\n    }\n    if (\"optional\" in schema) {\n        return schema.optional();\n    }\n    return schema;\n}\nconst deepHas = (obj, p)=>{\n    const path = [\n        ...(0,property_expr__WEBPACK_IMPORTED_MODULE_0__.normalizePath)(p)\n    ];\n    if (path.length === 1) return path[0] in obj;\n    let last = path.pop();\n    let parent = (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.getter)((0,property_expr__WEBPACK_IMPORTED_MODULE_0__.join)(path), true)(obj);\n    return !!(parent && last in parent);\n};\nlet isObject = (obj)=>Object.prototype.toString.call(obj) === \"[object Object]\";\nfunction unknown(ctx, value) {\n    let known = Object.keys(ctx.fields);\n    return Object.keys(value).filter((key)=>known.indexOf(key) === -1);\n}\nconst defaultSort = sortByKeyOrder([]);\nfunction create$3(spec) {\n    return new ObjectSchema(spec);\n}\nclass ObjectSchema extends Schema {\n    constructor(spec){\n        super({\n            type: \"object\",\n            check (value) {\n                return isObject(value) || typeof value === \"function\";\n            }\n        });\n        this.fields = Object.create(null);\n        this._sortErrors = defaultSort;\n        this._nodes = [];\n        this._excludedEdges = [];\n        this.withMutation(()=>{\n            if (spec) {\n                this.shape(spec);\n            }\n        });\n    }\n    _cast(_value, options = {}) {\n        var _options$stripUnknown;\n        let value = super._cast(_value, options);\n        //should ignore nulls here\n        if (value === undefined) return this.getDefault(options);\n        if (!this._typeCheck(value)) return value;\n        let fields = this.fields;\n        let strip = (_options$stripUnknown = options.stripUnknown) != null ? _options$stripUnknown : this.spec.noUnknown;\n        let props = [].concat(this._nodes, Object.keys(value).filter((v)=>!this._nodes.includes(v)));\n        let intermediateValue = {}; // is filled during the transform below\n        let innerOptions = Object.assign({}, options, {\n            parent: intermediateValue,\n            __validating: options.__validating || false\n        });\n        let isChanged = false;\n        for (const prop of props){\n            let field = fields[prop];\n            let exists = prop in value;\n            if (field) {\n                let fieldValue;\n                let inputValue = value[prop];\n                // safe to mutate since this is fired in sequence\n                innerOptions.path = (options.path ? `${options.path}.` : \"\") + prop;\n                field = field.resolve({\n                    value: inputValue,\n                    context: options.context,\n                    parent: intermediateValue\n                });\n                let fieldSpec = field instanceof Schema ? field.spec : undefined;\n                let strict = fieldSpec == null ? void 0 : fieldSpec.strict;\n                if (fieldSpec != null && fieldSpec.strip) {\n                    isChanged = isChanged || prop in value;\n                    continue;\n                }\n                fieldValue = !options.__validating || !strict ? // TODO: use _cast, this is double resolving\n                field.cast(value[prop], innerOptions) : value[prop];\n                if (fieldValue !== undefined) {\n                    intermediateValue[prop] = fieldValue;\n                }\n            } else if (exists && !strip) {\n                intermediateValue[prop] = value[prop];\n            }\n            if (exists !== prop in intermediateValue || intermediateValue[prop] !== value[prop]) {\n                isChanged = true;\n            }\n        }\n        return isChanged ? intermediateValue : value;\n    }\n    _validate(_value, options = {}, panic, next) {\n        let { from = [], originalValue = _value, recursive = this.spec.recursive } = options;\n        options.from = [\n            {\n                schema: this,\n                value: originalValue\n            },\n            ...from\n        ];\n        // this flag is needed for handling `strict` correctly in the context of\n        // validation vs just casting. e.g strict() on a field is only used when validating\n        options.__validating = true;\n        options.originalValue = originalValue;\n        super._validate(_value, options, panic, (objectErrors, value)=>{\n            if (!recursive || !isObject(value)) {\n                next(objectErrors, value);\n                return;\n            }\n            originalValue = originalValue || value;\n            let tests = [];\n            for (let key of this._nodes){\n                let field = this.fields[key];\n                if (!field || Reference.isRef(field)) {\n                    continue;\n                }\n                tests.push(field.asNestedTest({\n                    options,\n                    key,\n                    parent: value,\n                    parentPath: options.path,\n                    originalParent: originalValue\n                }));\n            }\n            this.runTests({\n                tests,\n                value,\n                originalValue,\n                options\n            }, panic, (fieldErrors)=>{\n                next(fieldErrors.sort(this._sortErrors).concat(objectErrors), value);\n            });\n        });\n    }\n    clone(spec) {\n        const next = super.clone(spec);\n        next.fields = Object.assign({}, this.fields);\n        next._nodes = this._nodes;\n        next._excludedEdges = this._excludedEdges;\n        next._sortErrors = this._sortErrors;\n        return next;\n    }\n    concat(schema) {\n        let next = super.concat(schema);\n        let nextFields = next.fields;\n        for (let [field, schemaOrRef] of Object.entries(this.fields)){\n            const target = nextFields[field];\n            nextFields[field] = target === undefined ? schemaOrRef : target;\n        }\n        return next.withMutation((s)=>// XXX: excludes here is wrong\n            s.setFields(nextFields, [\n                ...this._excludedEdges,\n                ...schema._excludedEdges\n            ]));\n    }\n    _getDefault(options) {\n        if (\"default\" in this.spec) {\n            return super._getDefault(options);\n        }\n        // if there is no default set invent one\n        if (!this._nodes.length) {\n            return undefined;\n        }\n        let dft = {};\n        this._nodes.forEach((key)=>{\n            var _innerOptions;\n            const field = this.fields[key];\n            let innerOptions = options;\n            if ((_innerOptions = innerOptions) != null && _innerOptions.value) {\n                innerOptions = Object.assign({}, innerOptions, {\n                    parent: innerOptions.value,\n                    value: innerOptions.value[key]\n                });\n            }\n            dft[key] = field && \"getDefault\" in field ? field.getDefault(innerOptions) : undefined;\n        });\n        return dft;\n    }\n    setFields(shape, excludedEdges) {\n        let next = this.clone();\n        next.fields = shape;\n        next._nodes = sortFields(shape, excludedEdges);\n        next._sortErrors = sortByKeyOrder(Object.keys(shape));\n        // XXX: this carries over edges which may not be what you want\n        if (excludedEdges) next._excludedEdges = excludedEdges;\n        return next;\n    }\n    shape(additions, excludes = []) {\n        return this.clone().withMutation((next)=>{\n            let edges = next._excludedEdges;\n            if (excludes.length) {\n                if (!Array.isArray(excludes[0])) excludes = [\n                    excludes\n                ];\n                edges = [\n                    ...next._excludedEdges,\n                    ...excludes\n                ];\n            }\n            // XXX: excludes here is wrong\n            return next.setFields(Object.assign(next.fields, additions), edges);\n        });\n    }\n    partial() {\n        const partial = {};\n        for (const [key, schema] of Object.entries(this.fields)){\n            partial[key] = \"optional\" in schema && schema.optional instanceof Function ? schema.optional() : schema;\n        }\n        return this.setFields(partial);\n    }\n    deepPartial() {\n        const next = deepPartial(this);\n        return next;\n    }\n    pick(keys) {\n        const picked = {};\n        for (const key of keys){\n            if (this.fields[key]) picked[key] = this.fields[key];\n        }\n        return this.setFields(picked, this._excludedEdges.filter(([a, b])=>keys.includes(a) && keys.includes(b)));\n    }\n    omit(keys) {\n        const remaining = [];\n        for (const key of Object.keys(this.fields)){\n            if (keys.includes(key)) continue;\n            remaining.push(key);\n        }\n        return this.pick(remaining);\n    }\n    from(from, to, alias) {\n        let fromGetter = (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.getter)(from, true);\n        return this.transform((obj)=>{\n            if (!obj) return obj;\n            let newObj = obj;\n            if (deepHas(obj, from)) {\n                newObj = Object.assign({}, obj);\n                if (!alias) delete newObj[from];\n                newObj[to] = fromGetter(obj);\n            }\n            return newObj;\n        });\n    }\n    /** Parse an input JSON string to an object */ json() {\n        return this.transform(parseJson);\n    }\n    noUnknown(noAllow = true, message = object.noUnknown) {\n        if (typeof noAllow !== \"boolean\") {\n            message = noAllow;\n            noAllow = true;\n        }\n        let next = this.test({\n            name: \"noUnknown\",\n            exclusive: true,\n            message: message,\n            test (value) {\n                if (value == null) return true;\n                const unknownKeys = unknown(this.schema, value);\n                return !noAllow || unknownKeys.length === 0 || this.createError({\n                    params: {\n                        unknown: unknownKeys.join(\", \")\n                    }\n                });\n            }\n        });\n        next.spec.noUnknown = noAllow;\n        return next;\n    }\n    unknown(allow = true, message = object.noUnknown) {\n        return this.noUnknown(!allow, message);\n    }\n    transformKeys(fn) {\n        return this.transform((obj)=>{\n            if (!obj) return obj;\n            const result = {};\n            for (const key of Object.keys(obj))result[fn(key)] = obj[key];\n            return result;\n        });\n    }\n    camelCase() {\n        return this.transformKeys(tiny_case__WEBPACK_IMPORTED_MODULE_1__.camelCase);\n    }\n    snakeCase() {\n        return this.transformKeys(tiny_case__WEBPACK_IMPORTED_MODULE_1__.snakeCase);\n    }\n    constantCase() {\n        return this.transformKeys((key)=>(0,tiny_case__WEBPACK_IMPORTED_MODULE_1__.snakeCase)(key).toUpperCase());\n    }\n    describe(options) {\n        const next = (options ? this.resolve(options) : this).clone();\n        const base = super.describe(options);\n        base.fields = {};\n        for (const [key, value] of Object.entries(next.fields)){\n            var _innerOptions2;\n            let innerOptions = options;\n            if ((_innerOptions2 = innerOptions) != null && _innerOptions2.value) {\n                innerOptions = Object.assign({}, innerOptions, {\n                    parent: innerOptions.value,\n                    value: innerOptions.value[key]\n                });\n            }\n            base.fields[key] = value.describe(innerOptions);\n        }\n        return base;\n    }\n}\ncreate$3.prototype = ObjectSchema.prototype;\nfunction create$2(type) {\n    return new ArraySchema(type);\n}\nclass ArraySchema extends Schema {\n    constructor(type){\n        super({\n            type: \"array\",\n            spec: {\n                types: type\n            },\n            check (v) {\n                return Array.isArray(v);\n            }\n        });\n        // `undefined` specifically means uninitialized, as opposed to \"no subtype\"\n        this.innerType = void 0;\n        this.innerType = type;\n    }\n    _cast(_value, _opts) {\n        const value = super._cast(_value, _opts);\n        // should ignore nulls here\n        if (!this._typeCheck(value) || !this.innerType) {\n            return value;\n        }\n        let isChanged = false;\n        const castArray = value.map((v, idx)=>{\n            const castElement = this.innerType.cast(v, Object.assign({}, _opts, {\n                path: `${_opts.path || \"\"}[${idx}]`\n            }));\n            if (castElement !== v) {\n                isChanged = true;\n            }\n            return castElement;\n        });\n        return isChanged ? castArray : value;\n    }\n    _validate(_value, options = {}, panic, next) {\n        var _options$recursive;\n        // let sync = options.sync;\n        // let path = options.path;\n        let innerType = this.innerType;\n        // let endEarly = options.abortEarly ?? this.spec.abortEarly;\n        let recursive = (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive;\n        options.originalValue != null ? options.originalValue : _value;\n        super._validate(_value, options, panic, (arrayErrors, value)=>{\n            var _options$originalValu2;\n            if (!recursive || !innerType || !this._typeCheck(value)) {\n                next(arrayErrors, value);\n                return;\n            }\n            // #950 Ensure that sparse array empty slots are validated\n            let tests = new Array(value.length);\n            for(let index = 0; index < value.length; index++){\n                var _options$originalValu;\n                tests[index] = innerType.asNestedTest({\n                    options,\n                    index,\n                    parent: value,\n                    parentPath: options.path,\n                    originalParent: (_options$originalValu = options.originalValue) != null ? _options$originalValu : _value\n                });\n            }\n            this.runTests({\n                value,\n                tests,\n                originalValue: (_options$originalValu2 = options.originalValue) != null ? _options$originalValu2 : _value,\n                options\n            }, panic, (innerTypeErrors)=>next(innerTypeErrors.concat(arrayErrors), value));\n        });\n    }\n    clone(spec) {\n        const next = super.clone(spec);\n        // @ts-expect-error readonly\n        next.innerType = this.innerType;\n        return next;\n    }\n    /** Parse an input JSON string to an object */ json() {\n        return this.transform(parseJson);\n    }\n    concat(schema) {\n        let next = super.concat(schema);\n        // @ts-expect-error readonly\n        next.innerType = this.innerType;\n        if (schema.innerType) // @ts-expect-error readonly\n        next.innerType = next.innerType ? // @ts-expect-error Lazy doesn't have concat and will break\n        next.innerType.concat(schema.innerType) : schema.innerType;\n        return next;\n    }\n    of(schema) {\n        // FIXME: this should return a new instance of array without the default to be\n        let next = this.clone();\n        if (!isSchema(schema)) throw new TypeError(\"`array.of()` sub-schema must be a valid yup schema not: \" + printValue(schema));\n        // @ts-expect-error readonly\n        next.innerType = schema;\n        next.spec = Object.assign({}, next.spec, {\n            types: schema\n        });\n        return next;\n    }\n    length(length, message = array.length) {\n        return this.test({\n            message,\n            name: \"length\",\n            exclusive: true,\n            params: {\n                length\n            },\n            skipAbsent: true,\n            test (value) {\n                return value.length === this.resolve(length);\n            }\n        });\n    }\n    min(min, message) {\n        message = message || array.min;\n        return this.test({\n            message,\n            name: \"min\",\n            exclusive: true,\n            params: {\n                min\n            },\n            skipAbsent: true,\n            // FIXME(ts): Array<typeof T>\n            test (value) {\n                return value.length >= this.resolve(min);\n            }\n        });\n    }\n    max(max, message) {\n        message = message || array.max;\n        return this.test({\n            message,\n            name: \"max\",\n            exclusive: true,\n            params: {\n                max\n            },\n            skipAbsent: true,\n            test (value) {\n                return value.length <= this.resolve(max);\n            }\n        });\n    }\n    ensure() {\n        return this.default(()=>[]).transform((val, original)=>{\n            // We don't want to return `null` for nullable schema\n            if (this._typeCheck(val)) return val;\n            return original == null ? [] : [].concat(original);\n        });\n    }\n    compact(rejector) {\n        let reject = !rejector ? (v)=>!!v : (v, i, a)=>!rejector(v, i, a);\n        return this.transform((values)=>values != null ? values.filter(reject) : values);\n    }\n    describe(options) {\n        const next = (options ? this.resolve(options) : this).clone();\n        const base = super.describe(options);\n        if (next.innerType) {\n            var _innerOptions;\n            let innerOptions = options;\n            if ((_innerOptions = innerOptions) != null && _innerOptions.value) {\n                innerOptions = Object.assign({}, innerOptions, {\n                    parent: innerOptions.value,\n                    value: innerOptions.value[0]\n                });\n            }\n            base.innerType = next.innerType.describe(innerOptions);\n        }\n        return base;\n    }\n}\ncreate$2.prototype = ArraySchema.prototype;\n// @ts-ignore\nfunction create$1(schemas) {\n    return new TupleSchema(schemas);\n}\nclass TupleSchema extends Schema {\n    constructor(schemas){\n        super({\n            type: \"tuple\",\n            spec: {\n                types: schemas\n            },\n            check (v) {\n                const types = this.spec.types;\n                return Array.isArray(v) && v.length === types.length;\n            }\n        });\n        this.withMutation(()=>{\n            this.typeError(tuple.notType);\n        });\n    }\n    _cast(inputValue, options) {\n        const { types } = this.spec;\n        const value = super._cast(inputValue, options);\n        if (!this._typeCheck(value)) {\n            return value;\n        }\n        let isChanged = false;\n        const castArray = types.map((type, idx)=>{\n            const castElement = type.cast(value[idx], Object.assign({}, options, {\n                path: `${options.path || \"\"}[${idx}]`\n            }));\n            if (castElement !== value[idx]) isChanged = true;\n            return castElement;\n        });\n        return isChanged ? castArray : value;\n    }\n    _validate(_value, options = {}, panic, next) {\n        let itemTypes = this.spec.types;\n        super._validate(_value, options, panic, (tupleErrors, value)=>{\n            var _options$originalValu2;\n            // intentionally not respecting recursive\n            if (!this._typeCheck(value)) {\n                next(tupleErrors, value);\n                return;\n            }\n            let tests = [];\n            for (let [index, itemSchema] of itemTypes.entries()){\n                var _options$originalValu;\n                tests[index] = itemSchema.asNestedTest({\n                    options,\n                    index,\n                    parent: value,\n                    parentPath: options.path,\n                    originalParent: (_options$originalValu = options.originalValue) != null ? _options$originalValu : _value\n                });\n            }\n            this.runTests({\n                value,\n                tests,\n                originalValue: (_options$originalValu2 = options.originalValue) != null ? _options$originalValu2 : _value,\n                options\n            }, panic, (innerTypeErrors)=>next(innerTypeErrors.concat(tupleErrors), value));\n        });\n    }\n    describe(options) {\n        const next = (options ? this.resolve(options) : this).clone();\n        const base = super.describe(options);\n        base.innerType = next.spec.types.map((schema, index)=>{\n            var _innerOptions;\n            let innerOptions = options;\n            if ((_innerOptions = innerOptions) != null && _innerOptions.value) {\n                innerOptions = Object.assign({}, innerOptions, {\n                    parent: innerOptions.value,\n                    value: innerOptions.value[index]\n                });\n            }\n            return schema.describe(innerOptions);\n        });\n        return base;\n    }\n}\ncreate$1.prototype = TupleSchema.prototype;\nfunction create(builder) {\n    return new Lazy(builder);\n}\nclass Lazy {\n    constructor(builder){\n        this.type = \"lazy\";\n        this.__isYupSchema__ = true;\n        this.spec = void 0;\n        this._resolve = (value, options = {})=>{\n            let schema = this.builder(value, options);\n            if (!isSchema(schema)) throw new TypeError(\"lazy() functions must return a valid schema\");\n            if (this.spec.optional) schema = schema.optional();\n            return schema.resolve(options);\n        };\n        this.builder = builder;\n        this.spec = {\n            meta: undefined,\n            optional: false\n        };\n    }\n    clone(spec) {\n        const next = new Lazy(this.builder);\n        next.spec = Object.assign({}, this.spec, spec);\n        return next;\n    }\n    optionality(optional) {\n        const next = this.clone({\n            optional\n        });\n        return next;\n    }\n    optional() {\n        return this.optionality(true);\n    }\n    resolve(options) {\n        return this._resolve(options.value, options);\n    }\n    cast(value, options) {\n        return this._resolve(value, options).cast(value, options);\n    }\n    asNestedTest(config) {\n        let { key, index, parent, options } = config;\n        let value = parent[index != null ? index : key];\n        return this._resolve(value, Object.assign({}, options, {\n            value,\n            parent\n        })).asNestedTest(config);\n    }\n    validate(value, options) {\n        return this._resolve(value, options).validate(value, options);\n    }\n    validateSync(value, options) {\n        return this._resolve(value, options).validateSync(value, options);\n    }\n    validateAt(path, value, options) {\n        return this._resolve(value, options).validateAt(path, value, options);\n    }\n    validateSyncAt(path, value, options) {\n        return this._resolve(value, options).validateSyncAt(path, value, options);\n    }\n    isValid(value, options) {\n        return this._resolve(value, options).isValid(value, options);\n    }\n    isValidSync(value, options) {\n        return this._resolve(value, options).isValidSync(value, options);\n    }\n    describe(options) {\n        return options ? this.resolve(options).describe(options) : {\n            type: \"lazy\",\n            meta: this.spec.meta,\n            label: undefined\n        };\n    }\n    meta(...args) {\n        if (args.length === 0) return this.spec.meta;\n        let next = this.clone();\n        next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);\n        return next;\n    }\n}\nfunction setLocale(custom) {\n    Object.keys(custom).forEach((type)=>{\n        // @ts-ignore\n        Object.keys(custom[type]).forEach((method)=>{\n            // @ts-ignore\n            locale[type][method] = custom[type][method];\n        });\n    });\n}\nfunction addMethod(schemaType, name, fn) {\n    if (!schemaType || !isSchema(schemaType.prototype)) throw new TypeError(\"You must provide a yup schema constructor function\");\n    if (typeof name !== \"string\") throw new TypeError(\"A Method name must be provided\");\n    if (typeof fn !== \"function\") throw new TypeError(\"Method function must be provided\");\n    schemaType.prototype[name] = fn;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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ZXguZXNtLmpzPzRjNzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0dGVyLCBmb3JFYWNoLCBzcGxpdCwgbm9ybWFsaXplUGF0aCwgam9pbiB9IGZyb20gJ3Byb3BlcnR5LWV4cHInO1xuaW1wb3J0IHsgY2FtZWxDYXNlLCBzbmFrZUNhc2UgfSBmcm9tICd0aW55LWNhc2UnO1xuaW1wb3J0IHRvcG9zb3J0IGZyb20gJ3RvcG9zb3J0JztcblxuY29uc3QgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuY29uc3QgZXJyb3JUb1N0cmluZyA9IEVycm9yLnByb3RvdHlwZS50b1N0cmluZztcbmNvbnN0IHJlZ0V4cFRvU3RyaW5nID0gUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZztcbmNvbnN0IHN5bWJvbFRvU3RyaW5nID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgPyBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nIDogKCkgPT4gJyc7XG5jb25zdCBTWU1CT0xfUkVHRVhQID0gL15TeW1ib2xcXCgoLiopXFwpKC4qKSQvO1xuZnVuY3Rpb24gcHJpbnROdW1iZXIodmFsKSB7XG4gIGlmICh2YWwgIT0gK3ZhbCkgcmV0dXJuICdOYU4nO1xuICBjb25zdCBpc05lZ2F0aXZlWmVybyA9IHZhbCA9PT0gMCAmJiAxIC8gdmFsIDwgMDtcbiAgcmV0dXJuIGlzTmVnYXRpdmVaZXJvID8gJy0wJyA6ICcnICsgdmFsO1xufVxuZnVuY3Rpb24gcHJpbnRTaW1wbGVWYWx1ZSh2YWwsIHF1b3RlU3RyaW5ncyA9IGZhbHNlKSB7XG4gIGlmICh2YWwgPT0gbnVsbCB8fCB2YWwgPT09IHRydWUgfHwgdmFsID09PSBmYWxzZSkgcmV0dXJuICcnICsgdmFsO1xuICBjb25zdCB0eXBlT2YgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZU9mID09PSAnbnVtYmVyJykgcmV0dXJuIHByaW50TnVtYmVyKHZhbCk7XG4gIGlmICh0eXBlT2YgPT09ICdzdHJpbmcnKSByZXR1cm4gcXVvdGVTdHJpbmdzID8gYFwiJHt2YWx9XCJgIDogdmFsO1xuICBpZiAodHlwZU9mID09PSAnZnVuY3Rpb24nKSByZXR1cm4gJ1tGdW5jdGlvbiAnICsgKHZhbC5uYW1lIHx8ICdhbm9ueW1vdXMnKSArICddJztcbiAgaWYgKHR5cGVPZiA9PT0gJ3N5bWJvbCcpIHJldHVybiBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbCkucmVwbGFjZShTWU1CT0xfUkVHRVhQLCAnU3ltYm9sKCQxKScpO1xuICBjb25zdCB0YWcgPSB0b1N0cmluZy5jYWxsKHZhbCkuc2xpY2UoOCwgLTEpO1xuICBpZiAodGFnID09PSAnRGF0ZScpIHJldHVybiBpc05hTih2YWwuZ2V0VGltZSgpKSA/ICcnICsgdmFsIDogdmFsLnRvSVNPU3RyaW5nKHZhbCk7XG4gIGlmICh0YWcgPT09ICdFcnJvcicgfHwgdmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiAnWycgKyBlcnJvclRvU3RyaW5nLmNhbGwodmFsKSArICddJztcbiAgaWYgKHRhZyA9PT0gJ1JlZ0V4cCcpIHJldHVybiByZWdFeHBUb1N0cmluZy5jYWxsKHZhbCk7XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcHJpbnRWYWx1ZSh2YWx1ZSwgcXVvdGVTdHJpbmdzKSB7XG4gIGxldCByZXN1bHQgPSBwcmludFNpbXBsZVZhbHVlKHZhbHVlLCBxdW90ZVN0cmluZ3MpO1xuICBpZiAocmVzdWx0ICE9PSBudWxsKSByZXR1cm4gcmVzdWx0O1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgbGV0IHJlc3VsdCA9IHByaW50U2ltcGxlVmFsdWUodGhpc1trZXldLCBxdW90ZVN0cmluZ3MpO1xuICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LCAyKTtcbn1cblxuZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFtdIDogW10uY29uY2F0KHZhbHVlKTtcbn1cblxubGV0IF9TeW1ib2wkdG9TdHJpbmdUYWcsIF9TeW1ib2wkaGFzSW5zdGFuY2UsIF9TeW1ib2wkdG9TdHJpbmdUYWcyO1xubGV0IHN0clJlZyA9IC9cXCRcXHtcXHMqKFxcdyspXFxzKlxcfS9nO1xuX1N5bWJvbCR0b1N0cmluZ1RhZyA9IFN5bWJvbC50b1N0cmluZ1RhZztcbmNsYXNzIFZhbGlkYXRpb25FcnJvck5vU3RhY2sge1xuICBjb25zdHJ1Y3RvcihlcnJvck9yRXJyb3JzLCB2YWx1ZSwgZmllbGQsIHR5cGUpIHtcbiAgICB0aGlzLm5hbWUgPSB2b2lkIDA7XG4gICAgdGhpcy5tZXNzYWdlID0gdm9pZCAwO1xuICAgIHRoaXMudmFsdWUgPSB2b2lkIDA7XG4gICAgdGhpcy5wYXRoID0gdm9pZCAwO1xuICAgIHRoaXMudHlwZSA9IHZvaWQgMDtcbiAgICB0aGlzLnBhcmFtcyA9IHZvaWQgMDtcbiAgICB0aGlzLmVycm9ycyA9IHZvaWQgMDtcbiAgICB0aGlzLmlubmVyID0gdm9pZCAwO1xuICAgIHRoaXNbX1N5bWJvbCR0b1N0cmluZ1RhZ10gPSAnRXJyb3InO1xuICAgIHRoaXMubmFtZSA9ICdWYWxpZGF0aW9uRXJyb3InO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLnBhdGggPSBmaWVsZDtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgdGhpcy5pbm5lciA9IFtdO1xuICAgIHRvQXJyYXkoZXJyb3JPckVycm9ycykuZm9yRWFjaChlcnIgPT4ge1xuICAgICAgaWYgKFZhbGlkYXRpb25FcnJvci5pc0Vycm9yKGVycikpIHtcbiAgICAgICAgdGhpcy5lcnJvcnMucHVzaCguLi5lcnIuZXJyb3JzKTtcbiAgICAgICAgY29uc3QgaW5uZXJFcnJvcnMgPSBlcnIuaW5uZXIubGVuZ3RoID8gZXJyLmlubmVyIDogW2Vycl07XG4gICAgICAgIHRoaXMuaW5uZXIucHVzaCguLi5pbm5lckVycm9ycyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVycm9ycy5wdXNoKGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5tZXNzYWdlID0gdGhpcy5lcnJvcnMubGVuZ3RoID4gMSA/IGAke3RoaXMuZXJyb3JzLmxlbmd0aH0gZXJyb3JzIG9jY3VycmVkYCA6IHRoaXMuZXJyb3JzWzBdO1xuICB9XG59XG5fU3ltYm9sJGhhc0luc3RhbmNlID0gU3ltYm9sLmhhc0luc3RhbmNlO1xuX1N5bWJvbCR0b1N0cmluZ1RhZzIgPSBTeW1ib2wudG9TdHJpbmdUYWc7XG5jbGFzcyBWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHN0YXRpYyBmb3JtYXRFcnJvcihtZXNzYWdlLCBwYXJhbXMpIHtcbiAgICBjb25zdCBwYXRoID0gcGFyYW1zLmxhYmVsIHx8IHBhcmFtcy5wYXRoIHx8ICd0aGlzJztcbiAgICBpZiAocGF0aCAhPT0gcGFyYW1zLnBhdGgpIHBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcywge1xuICAgICAgcGF0aFxuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHJldHVybiBtZXNzYWdlLnJlcGxhY2Uoc3RyUmVnLCAoXywga2V5KSA9PiBwcmludFZhbHVlKHBhcmFtc1trZXldKSk7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnZnVuY3Rpb24nKSByZXR1cm4gbWVzc2FnZShwYXJhbXMpO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIHN0YXRpYyBpc0Vycm9yKGVycikge1xuICAgIHJldHVybiBlcnIgJiYgZXJyLm5hbWUgPT09ICdWYWxpZGF0aW9uRXJyb3InO1xuICB9XG4gIGNvbnN0cnVjdG9yKGVycm9yT3JFcnJvcnMsIHZhbHVlLCBmaWVsZCwgdHlwZSwgZGlzYWJsZVN0YWNrKSB7XG4gICAgY29uc3QgZXJyb3JOb1N0YWNrID0gbmV3IFZhbGlkYXRpb25FcnJvck5vU3RhY2soZXJyb3JPckVycm9ycywgdmFsdWUsIGZpZWxkLCB0eXBlKTtcbiAgICBpZiAoZGlzYWJsZVN0YWNrKSB7XG4gICAgICByZXR1cm4gZXJyb3JOb1N0YWNrO1xuICAgIH1cbiAgICBzdXBlcigpO1xuICAgIHRoaXMudmFsdWUgPSB2b2lkIDA7XG4gICAgdGhpcy5wYXRoID0gdm9pZCAwO1xuICAgIHRoaXMudHlwZSA9IHZvaWQgMDtcbiAgICB0aGlzLnBhcmFtcyA9IHZvaWQgMDtcbiAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgIHRoaXMuaW5uZXIgPSBbXTtcbiAgICB0aGlzW19TeW1ib2wkdG9TdHJpbmdUYWcyXSA9ICdFcnJvcic7XG4gICAgdGhpcy5uYW1lID0gZXJyb3JOb1N0YWNrLm5hbWU7XG4gICAgdGhpcy5tZXNzYWdlID0gZXJyb3JOb1N0YWNrLm1lc3NhZ2U7XG4gICAgdGhpcy50eXBlID0gZXJyb3JOb1N0YWNrLnR5cGU7XG4gICAgdGhpcy52YWx1ZSA9IGVycm9yTm9TdGFjay52YWx1ZTtcbiAgICB0aGlzLnBhdGggPSBlcnJvck5vU3RhY2sucGF0aDtcbiAgICB0aGlzLmVycm9ycyA9IGVycm9yTm9TdGFjay5lcnJvcnM7XG4gICAgdGhpcy5pbm5lciA9IGVycm9yTm9TdGFjay5pbm5lcjtcbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFZhbGlkYXRpb25FcnJvcik7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBbX1N5bWJvbCRoYXNJbnN0YW5jZV0oaW5zdCkge1xuICAgIHJldHVybiBWYWxpZGF0aW9uRXJyb3JOb1N0YWNrW1N5bWJvbC5oYXNJbnN0YW5jZV0oaW5zdCkgfHwgc3VwZXJbU3ltYm9sLmhhc0luc3RhbmNlXShpbnN0KTtcbiAgfVxufVxuXG5sZXQgbWl4ZWQgPSB7XG4gIGRlZmF1bHQ6ICcke3BhdGh9IGlzIGludmFsaWQnLFxuICByZXF1aXJlZDogJyR7cGF0aH0gaXMgYSByZXF1aXJlZCBmaWVsZCcsXG4gIGRlZmluZWQ6ICcke3BhdGh9IG11c3QgYmUgZGVmaW5lZCcsXG4gIG5vdE51bGw6ICcke3BhdGh9IGNhbm5vdCBiZSBudWxsJyxcbiAgb25lT2Y6ICcke3BhdGh9IG11c3QgYmUgb25lIG9mIHRoZSBmb2xsb3dpbmcgdmFsdWVzOiAke3ZhbHVlc30nLFxuICBub3RPbmVPZjogJyR7cGF0aH0gbXVzdCBub3QgYmUgb25lIG9mIHRoZSBmb2xsb3dpbmcgdmFsdWVzOiAke3ZhbHVlc30nLFxuICBub3RUeXBlOiAoe1xuICAgIHBhdGgsXG4gICAgdHlwZSxcbiAgICB2YWx1ZSxcbiAgICBvcmlnaW5hbFZhbHVlXG4gIH0pID0+IHtcbiAgICBjb25zdCBjYXN0TXNnID0gb3JpZ2luYWxWYWx1ZSAhPSBudWxsICYmIG9yaWdpbmFsVmFsdWUgIT09IHZhbHVlID8gYCAoY2FzdCBmcm9tIHRoZSB2YWx1ZSBcXGAke3ByaW50VmFsdWUob3JpZ2luYWxWYWx1ZSwgdHJ1ZSl9XFxgKS5gIDogJy4nO1xuICAgIHJldHVybiB0eXBlICE9PSAnbWl4ZWQnID8gYCR7cGF0aH0gbXVzdCBiZSBhIFxcYCR7dHlwZX1cXGAgdHlwZSwgYCArIGBidXQgdGhlIGZpbmFsIHZhbHVlIHdhczogXFxgJHtwcmludFZhbHVlKHZhbHVlLCB0cnVlKX1cXGBgICsgY2FzdE1zZyA6IGAke3BhdGh9IG11c3QgbWF0Y2ggdGhlIGNvbmZpZ3VyZWQgdHlwZS4gYCArIGBUaGUgdmFsaWRhdGVkIHZhbHVlIHdhczogXFxgJHtwcmludFZhbHVlKHZhbHVlLCB0cnVlKX1cXGBgICsgY2FzdE1zZztcbiAgfVxufTtcbmxldCBzdHJpbmcgPSB7XG4gIGxlbmd0aDogJyR7cGF0aH0gbXVzdCBiZSBleGFjdGx5ICR7bGVuZ3RofSBjaGFyYWN0ZXJzJyxcbiAgbWluOiAnJHtwYXRofSBtdXN0IGJlIGF0IGxlYXN0ICR7bWlufSBjaGFyYWN0ZXJzJyxcbiAgbWF4OiAnJHtwYXRofSBtdXN0IGJlIGF0IG1vc3QgJHttYXh9IGNoYXJhY3RlcnMnLFxuICBtYXRjaGVzOiAnJHtwYXRofSBtdXN0IG1hdGNoIHRoZSBmb2xsb3dpbmc6IFwiJHtyZWdleH1cIicsXG4gIGVtYWlsOiAnJHtwYXRofSBtdXN0IGJlIGEgdmFsaWQgZW1haWwnLFxuICB1cmw6ICcke3BhdGh9IG11c3QgYmUgYSB2YWxpZCBVUkwnLFxuICB1dWlkOiAnJHtwYXRofSBtdXN0IGJlIGEgdmFsaWQgVVVJRCcsXG4gIGRhdGV0aW1lOiAnJHtwYXRofSBtdXN0IGJlIGEgdmFsaWQgSVNPIGRhdGUtdGltZScsXG4gIGRhdGV0aW1lX3ByZWNpc2lvbjogJyR7cGF0aH0gbXVzdCBiZSBhIHZhbGlkIElTTyBkYXRlLXRpbWUgd2l0aCBhIHN1Yi1zZWNvbmQgcHJlY2lzaW9uIG9mIGV4YWN0bHkgJHtwcmVjaXNpb259IGRpZ2l0cycsXG4gIGRhdGV0aW1lX29mZnNldDogJyR7cGF0aH0gbXVzdCBiZSBhIHZhbGlkIElTTyBkYXRlLXRpbWUgd2l0aCBVVEMgXCJaXCIgdGltZXpvbmUnLFxuICB0cmltOiAnJHtwYXRofSBtdXN0IGJlIGEgdHJpbW1lZCBzdHJpbmcnLFxuICBsb3dlcmNhc2U6ICcke3BhdGh9IG11c3QgYmUgYSBsb3dlcmNhc2Ugc3RyaW5nJyxcbiAgdXBwZXJjYXNlOiAnJHtwYXRofSBtdXN0IGJlIGEgdXBwZXIgY2FzZSBzdHJpbmcnXG59O1xubGV0IG51bWJlciA9IHtcbiAgbWluOiAnJHtwYXRofSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAke21pbn0nLFxuICBtYXg6ICcke3BhdGh9IG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICR7bWF4fScsXG4gIGxlc3NUaGFuOiAnJHtwYXRofSBtdXN0IGJlIGxlc3MgdGhhbiAke2xlc3N9JyxcbiAgbW9yZVRoYW46ICcke3BhdGh9IG11c3QgYmUgZ3JlYXRlciB0aGFuICR7bW9yZX0nLFxuICBwb3NpdGl2ZTogJyR7cGF0aH0gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicsXG4gIG5lZ2F0aXZlOiAnJHtwYXRofSBtdXN0IGJlIGEgbmVnYXRpdmUgbnVtYmVyJyxcbiAgaW50ZWdlcjogJyR7cGF0aH0gbXVzdCBiZSBhbiBpbnRlZ2VyJ1xufTtcbmxldCBkYXRlID0ge1xuICBtaW46ICcke3BhdGh9IGZpZWxkIG11c3QgYmUgbGF0ZXIgdGhhbiAke21pbn0nLFxuICBtYXg6ICcke3BhdGh9IGZpZWxkIG11c3QgYmUgYXQgZWFybGllciB0aGFuICR7bWF4fSdcbn07XG5sZXQgYm9vbGVhbiA9IHtcbiAgaXNWYWx1ZTogJyR7cGF0aH0gZmllbGQgbXVzdCBiZSAke3ZhbHVlfSdcbn07XG5sZXQgb2JqZWN0ID0ge1xuICBub1Vua25vd246ICcke3BhdGh9IGZpZWxkIGhhcyB1bnNwZWNpZmllZCBrZXlzOiAke3Vua25vd259J1xufTtcbmxldCBhcnJheSA9IHtcbiAgbWluOiAnJHtwYXRofSBmaWVsZCBtdXN0IGhhdmUgYXQgbGVhc3QgJHttaW59IGl0ZW1zJyxcbiAgbWF4OiAnJHtwYXRofSBmaWVsZCBtdXN0IGhhdmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICR7bWF4fSBpdGVtcycsXG4gIGxlbmd0aDogJyR7cGF0aH0gbXVzdCBoYXZlICR7bGVuZ3RofSBpdGVtcydcbn07XG5sZXQgdHVwbGUgPSB7XG4gIG5vdFR5cGU6IHBhcmFtcyA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgcGF0aCxcbiAgICAgIHZhbHVlLFxuICAgICAgc3BlY1xuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZUxlbiA9IHNwZWMudHlwZXMubGVuZ3RoO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA8IHR5cGVMZW4pIHJldHVybiBgJHtwYXRofSB0dXBsZSB2YWx1ZSBoYXMgdG9vIGZldyBpdGVtcywgZXhwZWN0ZWQgYSBsZW5ndGggb2YgJHt0eXBlTGVufSBidXQgZ290ICR7dmFsdWUubGVuZ3RofSBmb3IgdmFsdWU6IFxcYCR7cHJpbnRWYWx1ZSh2YWx1ZSwgdHJ1ZSl9XFxgYDtcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiB0eXBlTGVuKSByZXR1cm4gYCR7cGF0aH0gdHVwbGUgdmFsdWUgaGFzIHRvbyBtYW55IGl0ZW1zLCBleHBlY3RlZCBhIGxlbmd0aCBvZiAke3R5cGVMZW59IGJ1dCBnb3QgJHt2YWx1ZS5sZW5ndGh9IGZvciB2YWx1ZTogXFxgJHtwcmludFZhbHVlKHZhbHVlLCB0cnVlKX1cXGBgO1xuICAgIH1cbiAgICByZXR1cm4gVmFsaWRhdGlvbkVycm9yLmZvcm1hdEVycm9yKG1peGVkLm5vdFR5cGUsIHBhcmFtcyk7XG4gIH1cbn07XG52YXIgbG9jYWxlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gIG1peGVkLFxuICBzdHJpbmcsXG4gIG51bWJlcixcbiAgZGF0ZSxcbiAgb2JqZWN0LFxuICBhcnJheSxcbiAgYm9vbGVhbixcbiAgdHVwbGVcbn0pO1xuXG5jb25zdCBpc1NjaGVtYSA9IG9iaiA9PiBvYmogJiYgb2JqLl9faXNZdXBTY2hlbWFfXztcblxuY2xhc3MgQ29uZGl0aW9uIHtcbiAgc3RhdGljIGZyb21PcHRpb25zKHJlZnMsIGNvbmZpZykge1xuICAgIGlmICghY29uZmlnLnRoZW4gJiYgIWNvbmZpZy5vdGhlcndpc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VpdGhlciBgdGhlbjpgIG9yIGBvdGhlcndpc2U6YCBpcyByZXF1aXJlZCBmb3IgYHdoZW4oKWAgY29uZGl0aW9ucycpO1xuICAgIGxldCB7XG4gICAgICBpcyxcbiAgICAgIHRoZW4sXG4gICAgICBvdGhlcndpc2VcbiAgICB9ID0gY29uZmlnO1xuICAgIGxldCBjaGVjayA9IHR5cGVvZiBpcyA9PT0gJ2Z1bmN0aW9uJyA/IGlzIDogKC4uLnZhbHVlcykgPT4gdmFsdWVzLmV2ZXJ5KHZhbHVlID0+IHZhbHVlID09PSBpcyk7XG4gICAgcmV0dXJuIG5ldyBDb25kaXRpb24ocmVmcywgKHZhbHVlcywgc2NoZW1hKSA9PiB7XG4gICAgICB2YXIgX2JyYW5jaDtcbiAgICAgIGxldCBicmFuY2ggPSBjaGVjayguLi52YWx1ZXMpID8gdGhlbiA6IG90aGVyd2lzZTtcbiAgICAgIHJldHVybiAoX2JyYW5jaCA9IGJyYW5jaCA9PSBudWxsID8gdm9pZCAwIDogYnJhbmNoKHNjaGVtYSkpICE9IG51bGwgPyBfYnJhbmNoIDogc2NoZW1hO1xuICAgIH0pO1xuICB9XG4gIGNvbnN0cnVjdG9yKHJlZnMsIGJ1aWxkZXIpIHtcbiAgICB0aGlzLmZuID0gdm9pZCAwO1xuICAgIHRoaXMucmVmcyA9IHJlZnM7XG4gICAgdGhpcy5yZWZzID0gcmVmcztcbiAgICB0aGlzLmZuID0gYnVpbGRlcjtcbiAgfVxuICByZXNvbHZlKGJhc2UsIG9wdGlvbnMpIHtcbiAgICBsZXQgdmFsdWVzID0gdGhpcy5yZWZzLm1hcChyZWYgPT5cbiAgICAvLyBUT0RPOiA/IG9wZXJhdG9yIGhlcmU/XG4gICAgcmVmLmdldFZhbHVlKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMudmFsdWUsIG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucGFyZW50LCBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmNvbnRleHQpKTtcbiAgICBsZXQgc2NoZW1hID0gdGhpcy5mbih2YWx1ZXMsIGJhc2UsIG9wdGlvbnMpO1xuICAgIGlmIChzY2hlbWEgPT09IHVuZGVmaW5lZCB8fFxuICAgIC8vIEB0cy1pZ25vcmUgdGhpcyBjYW4gYmUgYmFzZVxuICAgIHNjaGVtYSA9PT0gYmFzZSkge1xuICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxuICAgIGlmICghaXNTY2hlbWEoc2NoZW1hKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignY29uZGl0aW9ucyBtdXN0IHJldHVybiBhIHNjaGVtYSBvYmplY3QnKTtcbiAgICByZXR1cm4gc2NoZW1hLnJlc29sdmUob3B0aW9ucyk7XG4gIH1cbn1cblxuY29uc3QgcHJlZml4ZXMgPSB7XG4gIGNvbnRleHQ6ICckJyxcbiAgdmFsdWU6ICcuJ1xufTtcbmZ1bmN0aW9uIGNyZWF0ZSQ5KGtleSwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IFJlZmVyZW5jZShrZXksIG9wdGlvbnMpO1xufVxuY2xhc3MgUmVmZXJlbmNlIHtcbiAgY29uc3RydWN0b3Ioa2V5LCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLmlzQ29udGV4dCA9IHZvaWQgMDtcbiAgICB0aGlzLmlzVmFsdWUgPSB2b2lkIDA7XG4gICAgdGhpcy5pc1NpYmxpbmcgPSB2b2lkIDA7XG4gICAgdGhpcy5wYXRoID0gdm9pZCAwO1xuICAgIHRoaXMuZ2V0dGVyID0gdm9pZCAwO1xuICAgIHRoaXMubWFwID0gdm9pZCAwO1xuICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IFR5cGVFcnJvcigncmVmIG11c3QgYmUgYSBzdHJpbmcsIGdvdDogJyArIGtleSk7XG4gICAgdGhpcy5rZXkgPSBrZXkudHJpbSgpO1xuICAgIGlmIChrZXkgPT09ICcnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZWYgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB0aGlzLmlzQ29udGV4dCA9IHRoaXMua2V5WzBdID09PSBwcmVmaXhlcy5jb250ZXh0O1xuICAgIHRoaXMuaXNWYWx1ZSA9IHRoaXMua2V5WzBdID09PSBwcmVmaXhlcy52YWx1ZTtcbiAgICB0aGlzLmlzU2libGluZyA9ICF0aGlzLmlzQ29udGV4dCAmJiAhdGhpcy5pc1ZhbHVlO1xuICAgIGxldCBwcmVmaXggPSB0aGlzLmlzQ29udGV4dCA/IHByZWZpeGVzLmNvbnRleHQgOiB0aGlzLmlzVmFsdWUgPyBwcmVmaXhlcy52YWx1ZSA6ICcnO1xuICAgIHRoaXMucGF0aCA9IHRoaXMua2V5LnNsaWNlKHByZWZpeC5sZW5ndGgpO1xuICAgIHRoaXMuZ2V0dGVyID0gdGhpcy5wYXRoICYmIGdldHRlcih0aGlzLnBhdGgsIHRydWUpO1xuICAgIHRoaXMubWFwID0gb3B0aW9ucy5tYXA7XG4gIH1cbiAgZ2V0VmFsdWUodmFsdWUsIHBhcmVudCwgY29udGV4dCkge1xuICAgIGxldCByZXN1bHQgPSB0aGlzLmlzQ29udGV4dCA/IGNvbnRleHQgOiB0aGlzLmlzVmFsdWUgPyB2YWx1ZSA6IHBhcmVudDtcbiAgICBpZiAodGhpcy5nZXR0ZXIpIHJlc3VsdCA9IHRoaXMuZ2V0dGVyKHJlc3VsdCB8fCB7fSk7XG4gICAgaWYgKHRoaXMubWFwKSByZXN1bHQgPSB0aGlzLm1hcChyZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMuY29udGV4dFxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMucGFyZW50XG4gICAqL1xuICBjYXN0KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUodmFsdWUsIG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucGFyZW50LCBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmNvbnRleHQpO1xuICB9XG4gIHJlc29sdmUoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZGVzY3JpYmUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdyZWYnLFxuICAgICAga2V5OiB0aGlzLmtleVxuICAgIH07XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBSZWYoJHt0aGlzLmtleX0pYDtcbiAgfVxuICBzdGF0aWMgaXNSZWYodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWUuX19pc1l1cFJlZjtcbiAgfVxufVxuXG4vLyBAdHMtaWdub3JlXG5SZWZlcmVuY2UucHJvdG90eXBlLl9faXNZdXBSZWYgPSB0cnVlO1xuXG5jb25zdCBpc0Fic2VudCA9IHZhbHVlID0+IHZhbHVlID09IG51bGw7XG5cbmZ1bmN0aW9uIGNyZWF0ZVZhbGlkYXRpb24oY29uZmlnKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHtcbiAgICB2YWx1ZSxcbiAgICBwYXRoID0gJycsXG4gICAgb3B0aW9ucyxcbiAgICBvcmlnaW5hbFZhbHVlLFxuICAgIHNjaGVtYVxuICB9LCBwYW5pYywgbmV4dCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG5hbWUsXG4gICAgICB0ZXN0LFxuICAgICAgcGFyYW1zLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIHNraXBBYnNlbnRcbiAgICB9ID0gY29uZmlnO1xuICAgIGxldCB7XG4gICAgICBwYXJlbnQsXG4gICAgICBjb250ZXh0LFxuICAgICAgYWJvcnRFYXJseSA9IHNjaGVtYS5zcGVjLmFib3J0RWFybHksXG4gICAgICBkaXNhYmxlU3RhY2tUcmFjZSA9IHNjaGVtYS5zcGVjLmRpc2FibGVTdGFja1RyYWNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgZnVuY3Rpb24gcmVzb2x2ZShpdGVtKSB7XG4gICAgICByZXR1cm4gUmVmZXJlbmNlLmlzUmVmKGl0ZW0pID8gaXRlbS5nZXRWYWx1ZSh2YWx1ZSwgcGFyZW50LCBjb250ZXh0KSA6IGl0ZW07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUVycm9yKG92ZXJyaWRlcyA9IHt9KSB7XG4gICAgICBjb25zdCBuZXh0UGFyYW1zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBvcmlnaW5hbFZhbHVlLFxuICAgICAgICBsYWJlbDogc2NoZW1hLnNwZWMubGFiZWwsXG4gICAgICAgIHBhdGg6IG92ZXJyaWRlcy5wYXRoIHx8IHBhdGgsXG4gICAgICAgIHNwZWM6IHNjaGVtYS5zcGVjLFxuICAgICAgICBkaXNhYmxlU3RhY2tUcmFjZTogb3ZlcnJpZGVzLmRpc2FibGVTdGFja1RyYWNlIHx8IGRpc2FibGVTdGFja1RyYWNlXG4gICAgICB9LCBwYXJhbXMsIG92ZXJyaWRlcy5wYXJhbXMpO1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMobmV4dFBhcmFtcykpIG5leHRQYXJhbXNba2V5XSA9IHJlc29sdmUobmV4dFBhcmFtc1trZXldKTtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IFZhbGlkYXRpb25FcnJvcihWYWxpZGF0aW9uRXJyb3IuZm9ybWF0RXJyb3Iob3ZlcnJpZGVzLm1lc3NhZ2UgfHwgbWVzc2FnZSwgbmV4dFBhcmFtcyksIHZhbHVlLCBuZXh0UGFyYW1zLnBhdGgsIG92ZXJyaWRlcy50eXBlIHx8IG5hbWUsIG5leHRQYXJhbXMuZGlzYWJsZVN0YWNrVHJhY2UpO1xuICAgICAgZXJyb3IucGFyYW1zID0gbmV4dFBhcmFtcztcbiAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gICAgY29uc3QgaW52YWxpZCA9IGFib3J0RWFybHkgPyBwYW5pYyA6IG5leHQ7XG4gICAgbGV0IGN0eCA9IHtcbiAgICAgIHBhdGgsXG4gICAgICBwYXJlbnQsXG4gICAgICB0eXBlOiBuYW1lLFxuICAgICAgZnJvbTogb3B0aW9ucy5mcm9tLFxuICAgICAgY3JlYXRlRXJyb3IsXG4gICAgICByZXNvbHZlLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIG9yaWdpbmFsVmFsdWUsXG4gICAgICBzY2hlbWFcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZVJlc3VsdCA9IHZhbGlkT3JFcnJvciA9PiB7XG4gICAgICBpZiAoVmFsaWRhdGlvbkVycm9yLmlzRXJyb3IodmFsaWRPckVycm9yKSkgaW52YWxpZCh2YWxpZE9yRXJyb3IpO2Vsc2UgaWYgKCF2YWxpZE9yRXJyb3IpIGludmFsaWQoY3JlYXRlRXJyb3IoKSk7ZWxzZSBuZXh0KG51bGwpO1xuICAgIH07XG4gICAgY29uc3QgaGFuZGxlRXJyb3IgPSBlcnIgPT4ge1xuICAgICAgaWYgKFZhbGlkYXRpb25FcnJvci5pc0Vycm9yKGVycikpIGludmFsaWQoZXJyKTtlbHNlIHBhbmljKGVycik7XG4gICAgfTtcbiAgICBjb25zdCBzaG91bGRTa2lwID0gc2tpcEFic2VudCAmJiBpc0Fic2VudCh2YWx1ZSk7XG4gICAgaWYgKHNob3VsZFNraXApIHtcbiAgICAgIHJldHVybiBoYW5kbGVSZXN1bHQodHJ1ZSk7XG4gICAgfVxuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBfcmVzdWx0O1xuICAgICAgcmVzdWx0ID0gdGVzdC5jYWxsKGN0eCwgdmFsdWUsIGN0eCk7XG4gICAgICBpZiAodHlwZW9mICgoX3Jlc3VsdCA9IHJlc3VsdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yZXN1bHQudGhlbikgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc3luYykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVmFsaWRhdGlvbiB0ZXN0IG9mIHR5cGU6IFwiJHtjdHgudHlwZX1cIiByZXR1cm5lZCBhIFByb21pc2UgZHVyaW5nIGEgc3luY2hyb25vdXMgdmFsaWRhdGUuIGAgKyBgVGhpcyB0ZXN0IHdpbGwgZmluaXNoIGFmdGVyIHRoZSB2YWxpZGF0ZSBjYWxsIGhhcyByZXR1cm5lZGApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KS50aGVuKGhhbmRsZVJlc3VsdCwgaGFuZGxlRXJyb3IpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaGFuZGxlRXJyb3IoZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaGFuZGxlUmVzdWx0KHJlc3VsdCk7XG4gIH1cbiAgdmFsaWRhdGUuT1BUSU9OUyA9IGNvbmZpZztcbiAgcmV0dXJuIHZhbGlkYXRlO1xufVxuXG5mdW5jdGlvbiBnZXRJbihzY2hlbWEsIHBhdGgsIHZhbHVlLCBjb250ZXh0ID0gdmFsdWUpIHtcbiAgbGV0IHBhcmVudCwgbGFzdFBhcnQsIGxhc3RQYXJ0RGVidWc7XG5cbiAgLy8gcm9vdCBwYXRoOiAnJ1xuICBpZiAoIXBhdGgpIHJldHVybiB7XG4gICAgcGFyZW50LFxuICAgIHBhcmVudFBhdGg6IHBhdGgsXG4gICAgc2NoZW1hXG4gIH07XG4gIGZvckVhY2gocGF0aCwgKF9wYXJ0LCBpc0JyYWNrZXQsIGlzQXJyYXkpID0+IHtcbiAgICBsZXQgcGFydCA9IGlzQnJhY2tldCA/IF9wYXJ0LnNsaWNlKDEsIF9wYXJ0Lmxlbmd0aCAtIDEpIDogX3BhcnQ7XG4gICAgc2NoZW1hID0gc2NoZW1hLnJlc29sdmUoe1xuICAgICAgY29udGV4dCxcbiAgICAgIHBhcmVudCxcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gICAgbGV0IGlzVHVwbGUgPSBzY2hlbWEudHlwZSA9PT0gJ3R1cGxlJztcbiAgICBsZXQgaWR4ID0gaXNBcnJheSA/IHBhcnNlSW50KHBhcnQsIDEwKSA6IDA7XG4gICAgaWYgKHNjaGVtYS5pbm5lclR5cGUgfHwgaXNUdXBsZSkge1xuICAgICAgaWYgKGlzVHVwbGUgJiYgIWlzQXJyYXkpIHRocm93IG5ldyBFcnJvcihgWXVwLnJlYWNoIGNhbm5vdCBpbXBsaWNpdGx5IGluZGV4IGludG8gYSB0dXBsZSB0eXBlLiB0aGUgcGF0aCBwYXJ0IFwiJHtsYXN0UGFydERlYnVnfVwiIG11c3QgY29udGFpbiBhbiBpbmRleCB0byB0aGUgdHVwbGUgZWxlbWVudCwgZS5nLiBcIiR7bGFzdFBhcnREZWJ1Z31bMF1cImApO1xuICAgICAgaWYgKHZhbHVlICYmIGlkeCA+PSB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBZdXAucmVhY2ggY2Fubm90IHJlc29sdmUgYW4gYXJyYXkgaXRlbSBhdCBpbmRleDogJHtfcGFydH0sIGluIHRoZSBwYXRoOiAke3BhdGh9LiBgICsgYGJlY2F1c2UgdGhlcmUgaXMgbm8gdmFsdWUgYXQgdGhhdCBpbmRleC4gYCk7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSB2YWx1ZTtcbiAgICAgIHZhbHVlID0gdmFsdWUgJiYgdmFsdWVbaWR4XTtcbiAgICAgIHNjaGVtYSA9IGlzVHVwbGUgPyBzY2hlbWEuc3BlYy50eXBlc1tpZHhdIDogc2NoZW1hLmlubmVyVHlwZTtcbiAgICB9XG5cbiAgICAvLyBzb21ldGltZXMgdGhlIGFycmF5IGluZGV4IHBhcnQgb2YgYSBwYXRoIGRvZXNuJ3QgZXhpc3Q6IFwibmVzdGVkLmFyci5jaGlsZFwiXG4gICAgLy8gaW4gdGhlc2UgY2FzZXMgdGhlIGN1cnJlbnQgcGFydCBpcyB0aGUgbmV4dCBzY2hlbWEgYW5kIHNob3VsZCBiZSBwcm9jZXNzZWRcbiAgICAvLyBpbiB0aGlzIGl0ZXJhdGlvbi4gRm9yIGNhc2VzIHdoZXJlIHRoZSBpbmRleCBzaWduYXR1cmUgaXMgaW5jbHVkZWQgdGhpc1xuICAgIC8vIGNoZWNrIHdpbGwgZmFpbCBhbmQgd2UnbGwgaGFuZGxlIHRoZSBgY2hpbGRgIHBhcnQgb24gdGhlIG5leHQgaXRlcmF0aW9uIGxpa2Ugbm9ybWFsXG4gICAgaWYgKCFpc0FycmF5KSB7XG4gICAgICBpZiAoIXNjaGVtYS5maWVsZHMgfHwgIXNjaGVtYS5maWVsZHNbcGFydF0pIHRocm93IG5ldyBFcnJvcihgVGhlIHNjaGVtYSBkb2VzIG5vdCBjb250YWluIHRoZSBwYXRoOiAke3BhdGh9LiBgICsgYChmYWlsZWQgYXQ6ICR7bGFzdFBhcnREZWJ1Z30gd2hpY2ggaXMgYSB0eXBlOiBcIiR7c2NoZW1hLnR5cGV9XCIpYCk7XG4gICAgICBwYXJlbnQgPSB2YWx1ZTtcbiAgICAgIHZhbHVlID0gdmFsdWUgJiYgdmFsdWVbcGFydF07XG4gICAgICBzY2hlbWEgPSBzY2hlbWEuZmllbGRzW3BhcnRdO1xuICAgIH1cbiAgICBsYXN0UGFydCA9IHBhcnQ7XG4gICAgbGFzdFBhcnREZWJ1ZyA9IGlzQnJhY2tldCA/ICdbJyArIF9wYXJ0ICsgJ10nIDogJy4nICsgX3BhcnQ7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHNjaGVtYSxcbiAgICBwYXJlbnQsXG4gICAgcGFyZW50UGF0aDogbGFzdFBhcnRcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlYWNoKG9iaiwgcGF0aCwgdmFsdWUsIGNvbnRleHQpIHtcbiAgcmV0dXJuIGdldEluKG9iaiwgcGF0aCwgdmFsdWUsIGNvbnRleHQpLnNjaGVtYTtcbn1cblxuY2xhc3MgUmVmZXJlbmNlU2V0IGV4dGVuZHMgU2V0IHtcbiAgZGVzY3JpYmUoKSB7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSBbXTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy52YWx1ZXMoKSkge1xuICAgICAgZGVzY3JpcHRpb24ucHVzaChSZWZlcmVuY2UuaXNSZWYoaXRlbSkgPyBpdGVtLmRlc2NyaWJlKCkgOiBpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICB9XG4gIHJlc29sdmVBbGwocmVzb2x2ZSkge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy52YWx1ZXMoKSkge1xuICAgICAgcmVzdWx0LnB1c2gocmVzb2x2ZShpdGVtKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBSZWZlcmVuY2VTZXQodGhpcy52YWx1ZXMoKSk7XG4gIH1cbiAgbWVyZ2UobmV3SXRlbXMsIHJlbW92ZUl0ZW1zKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuY2xvbmUoKTtcbiAgICBuZXdJdGVtcy5mb3JFYWNoKHZhbHVlID0+IG5leHQuYWRkKHZhbHVlKSk7XG4gICAgcmVtb3ZlSXRlbXMuZm9yRWFjaCh2YWx1ZSA9PiBuZXh0LmRlbGV0ZSh2YWx1ZSkpO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG59XG5cbi8vIHR3ZWFrZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vS2VsaW4yMDI1L25hbm9jbG9uZS9ibG9iLzBhYmViNzYzNWJkYTliNjhlZjIyNzcwOTNmNzZkYmUzYmYzOTQ4ZTEvc3JjL2luZGV4LmpzXG5mdW5jdGlvbiBjbG9uZShzcmMsIHNlZW4gPSBuZXcgTWFwKCkpIHtcbiAgaWYgKGlzU2NoZW1hKHNyYykgfHwgIXNyYyB8fCB0eXBlb2Ygc3JjICE9PSAnb2JqZWN0JykgcmV0dXJuIHNyYztcbiAgaWYgKHNlZW4uaGFzKHNyYykpIHJldHVybiBzZWVuLmdldChzcmMpO1xuICBsZXQgY29weTtcbiAgaWYgKHNyYyBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAvLyBEYXRlXG4gICAgY29weSA9IG5ldyBEYXRlKHNyYy5nZXRUaW1lKCkpO1xuICAgIHNlZW4uc2V0KHNyYywgY29weSk7XG4gIH0gZWxzZSBpZiAoc3JjIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgLy8gUmVnRXhwXG4gICAgY29weSA9IG5ldyBSZWdFeHAoc3JjKTtcbiAgICBzZWVuLnNldChzcmMsIGNvcHkpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc3JjKSkge1xuICAgIC8vIEFycmF5XG4gICAgY29weSA9IG5ldyBBcnJheShzcmMubGVuZ3RoKTtcbiAgICBzZWVuLnNldChzcmMsIGNvcHkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3JjLmxlbmd0aDsgaSsrKSBjb3B5W2ldID0gY2xvbmUoc3JjW2ldLCBzZWVuKTtcbiAgfSBlbHNlIGlmIChzcmMgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAvLyBNYXBcbiAgICBjb3B5ID0gbmV3IE1hcCgpO1xuICAgIHNlZW4uc2V0KHNyYywgY29weSk7XG4gICAgZm9yIChjb25zdCBbaywgdl0gb2Ygc3JjLmVudHJpZXMoKSkgY29weS5zZXQoaywgY2xvbmUodiwgc2VlbikpO1xuICB9IGVsc2UgaWYgKHNyYyBpbnN0YW5jZW9mIFNldCkge1xuICAgIC8vIFNldFxuICAgIGNvcHkgPSBuZXcgU2V0KCk7XG4gICAgc2Vlbi5zZXQoc3JjLCBjb3B5KTtcbiAgICBmb3IgKGNvbnN0IHYgb2Ygc3JjKSBjb3B5LmFkZChjbG9uZSh2LCBzZWVuKSk7XG4gIH0gZWxzZSBpZiAoc3JjIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgLy8gT2JqZWN0XG4gICAgY29weSA9IHt9O1xuICAgIHNlZW4uc2V0KHNyYywgY29weSk7XG4gICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMoc3JjKSkgY29weVtrXSA9IGNsb25lKHYsIHNlZW4pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IEVycm9yKGBVbmFibGUgdG8gY2xvbmUgJHtzcmN9YCk7XG4gIH1cbiAgcmV0dXJuIGNvcHk7XG59XG5cbi8vIElmIGBDdXN0b21TY2hlbWFNZXRhYCBpc24ndCBleHRlbmRlZCB3aXRoIGFueSBrZXlzLCB3ZSdsbCBmYWxsIGJhY2sgdG8gYVxuLy8gbG9vc2UgUmVjb3JkIGRlZmluaXRpb24gYWxsb3dpbmcgZnJlZSBmb3JtIHVzYWdlLlxuY2xhc3MgU2NoZW1hIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9IHZvaWQgMDtcbiAgICB0aGlzLmRlcHMgPSBbXTtcbiAgICB0aGlzLnRlc3RzID0gdm9pZCAwO1xuICAgIHRoaXMudHJhbnNmb3JtcyA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbmRpdGlvbnMgPSBbXTtcbiAgICB0aGlzLl9tdXRhdGUgPSB2b2lkIDA7XG4gICAgdGhpcy5pbnRlcm5hbFRlc3RzID0ge307XG4gICAgdGhpcy5fd2hpdGVsaXN0ID0gbmV3IFJlZmVyZW5jZVNldCgpO1xuICAgIHRoaXMuX2JsYWNrbGlzdCA9IG5ldyBSZWZlcmVuY2VTZXQoKTtcbiAgICB0aGlzLmV4Y2x1c2l2ZVRlc3RzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl90eXBlQ2hlY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5zcGVjID0gdm9pZCAwO1xuICAgIHRoaXMudGVzdHMgPSBbXTtcbiAgICB0aGlzLnRyYW5zZm9ybXMgPSBbXTtcbiAgICB0aGlzLndpdGhNdXRhdGlvbigoKSA9PiB7XG4gICAgICB0aGlzLnR5cGVFcnJvcihtaXhlZC5ub3RUeXBlKTtcbiAgICB9KTtcbiAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGU7XG4gICAgdGhpcy5fdHlwZUNoZWNrID0gb3B0aW9ucy5jaGVjaztcbiAgICB0aGlzLnNwZWMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIHN0cmlwOiBmYWxzZSxcbiAgICAgIHN0cmljdDogZmFsc2UsXG4gICAgICBhYm9ydEVhcmx5OiB0cnVlLFxuICAgICAgcmVjdXJzaXZlOiB0cnVlLFxuICAgICAgZGlzYWJsZVN0YWNrVHJhY2U6IGZhbHNlLFxuICAgICAgbnVsbGFibGU6IGZhbHNlLFxuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICBjb2VyY2U6IHRydWVcbiAgICB9LCBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnNwZWMpO1xuICAgIHRoaXMud2l0aE11dGF0aW9uKHMgPT4ge1xuICAgICAgcy5ub25OdWxsYWJsZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gVE9ETzogcmVtb3ZlXG4gIGdldCBfdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlO1xuICB9XG4gIGNsb25lKHNwZWMpIHtcbiAgICBpZiAodGhpcy5fbXV0YXRlKSB7XG4gICAgICBpZiAoc3BlYykgT2JqZWN0LmFzc2lnbih0aGlzLnNwZWMsIHNwZWMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIG5lc3RlZCB2YWx1ZSBpcyBhIHNjaGVtYSB3ZSBjYW4gc2tpcCBjbG9uaW5nLCBzaW5jZVxuICAgIC8vIHRoZXkgYXJlIGFscmVhZHkgaW1tdXRhYmxlXG4gICAgY29uc3QgbmV4dCA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpKTtcblxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdGhpcyBpcyByZWFkb25seVxuICAgIG5leHQudHlwZSA9IHRoaXMudHlwZTtcbiAgICBuZXh0Ll90eXBlQ2hlY2sgPSB0aGlzLl90eXBlQ2hlY2s7XG4gICAgbmV4dC5fd2hpdGVsaXN0ID0gdGhpcy5fd2hpdGVsaXN0LmNsb25lKCk7XG4gICAgbmV4dC5fYmxhY2tsaXN0ID0gdGhpcy5fYmxhY2tsaXN0LmNsb25lKCk7XG4gICAgbmV4dC5pbnRlcm5hbFRlc3RzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5pbnRlcm5hbFRlc3RzKTtcbiAgICBuZXh0LmV4Y2x1c2l2ZVRlc3RzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5leGNsdXNpdmVUZXN0cyk7XG5cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHRoaXMgaXMgcmVhZG9ubHlcbiAgICBuZXh0LmRlcHMgPSBbLi4udGhpcy5kZXBzXTtcbiAgICBuZXh0LmNvbmRpdGlvbnMgPSBbLi4udGhpcy5jb25kaXRpb25zXTtcbiAgICBuZXh0LnRlc3RzID0gWy4uLnRoaXMudGVzdHNdO1xuICAgIG5leHQudHJhbnNmb3JtcyA9IFsuLi50aGlzLnRyYW5zZm9ybXNdO1xuICAgIG5leHQuc3BlYyA9IGNsb25lKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc3BlYywgc3BlYykpO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIGxhYmVsKGxhYmVsKSB7XG4gICAgbGV0IG5leHQgPSB0aGlzLmNsb25lKCk7XG4gICAgbmV4dC5zcGVjLmxhYmVsID0gbGFiZWw7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgbWV0YSguLi5hcmdzKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5zcGVjLm1ldGE7XG4gICAgbGV0IG5leHQgPSB0aGlzLmNsb25lKCk7XG4gICAgbmV4dC5zcGVjLm1ldGEgPSBPYmplY3QuYXNzaWduKG5leHQuc3BlYy5tZXRhIHx8IHt9LCBhcmdzWzBdKTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICB3aXRoTXV0YXRpb24oZm4pIHtcbiAgICBsZXQgYmVmb3JlID0gdGhpcy5fbXV0YXRlO1xuICAgIHRoaXMuX211dGF0ZSA9IHRydWU7XG4gICAgbGV0IHJlc3VsdCA9IGZuKHRoaXMpO1xuICAgIHRoaXMuX211dGF0ZSA9IGJlZm9yZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGNvbmNhdChzY2hlbWEpIHtcbiAgICBpZiAoIXNjaGVtYSB8fCBzY2hlbWEgPT09IHRoaXMpIHJldHVybiB0aGlzO1xuICAgIGlmIChzY2hlbWEudHlwZSAhPT0gdGhpcy50eXBlICYmIHRoaXMudHlwZSAhPT0gJ21peGVkJykgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IGNhbm5vdCBcXGBjb25jYXQoKVxcYCBzY2hlbWEncyBvZiBkaWZmZXJlbnQgdHlwZXM6ICR7dGhpcy50eXBlfSBhbmQgJHtzY2hlbWEudHlwZX1gKTtcbiAgICBsZXQgYmFzZSA9IHRoaXM7XG4gICAgbGV0IGNvbWJpbmVkID0gc2NoZW1hLmNsb25lKCk7XG4gICAgY29uc3QgbWVyZ2VkU3BlYyA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2Uuc3BlYywgY29tYmluZWQuc3BlYyk7XG4gICAgY29tYmluZWQuc3BlYyA9IG1lcmdlZFNwZWM7XG4gICAgY29tYmluZWQuaW50ZXJuYWxUZXN0cyA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2UuaW50ZXJuYWxUZXN0cywgY29tYmluZWQuaW50ZXJuYWxUZXN0cyk7XG5cbiAgICAvLyBtYW51YWxseSBtZXJnZSB0aGUgYmxhY2tsaXN0L3doaXRlbGlzdCAodGhlIG90aGVyIGBzY2hlbWFgIHRha2VzXG4gICAgLy8gcHJlY2VkZW5jZSBpbiBjYXNlIG9mIGNvbmZsaWN0cylcbiAgICBjb21iaW5lZC5fd2hpdGVsaXN0ID0gYmFzZS5fd2hpdGVsaXN0Lm1lcmdlKHNjaGVtYS5fd2hpdGVsaXN0LCBzY2hlbWEuX2JsYWNrbGlzdCk7XG4gICAgY29tYmluZWQuX2JsYWNrbGlzdCA9IGJhc2UuX2JsYWNrbGlzdC5tZXJnZShzY2hlbWEuX2JsYWNrbGlzdCwgc2NoZW1hLl93aGl0ZWxpc3QpO1xuXG4gICAgLy8gc3RhcnQgd2l0aCB0aGUgY3VycmVudCB0ZXN0c1xuICAgIGNvbWJpbmVkLnRlc3RzID0gYmFzZS50ZXN0cztcbiAgICBjb21iaW5lZC5leGNsdXNpdmVUZXN0cyA9IGJhc2UuZXhjbHVzaXZlVGVzdHM7XG5cbiAgICAvLyBtYW51YWxseSBhZGQgdGhlIG5ldyB0ZXN0cyB0byBlbnN1cmVcbiAgICAvLyB0aGUgZGVkdXBpbmcgbG9naWMgaXMgY29uc2lzdGVudFxuICAgIGNvbWJpbmVkLndpdGhNdXRhdGlvbihuZXh0ID0+IHtcbiAgICAgIHNjaGVtYS50ZXN0cy5mb3JFYWNoKGZuID0+IHtcbiAgICAgICAgbmV4dC50ZXN0KGZuLk9QVElPTlMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29tYmluZWQudHJhbnNmb3JtcyA9IFsuLi5iYXNlLnRyYW5zZm9ybXMsIC4uLmNvbWJpbmVkLnRyYW5zZm9ybXNdO1xuICAgIHJldHVybiBjb21iaW5lZDtcbiAgfVxuICBpc1R5cGUodikge1xuICAgIGlmICh2ID09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLnNwZWMubnVsbGFibGUgJiYgdiA9PT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAodGhpcy5zcGVjLm9wdGlvbmFsICYmIHYgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl90eXBlQ2hlY2sodik7XG4gIH1cbiAgcmVzb2x2ZShvcHRpb25zKSB7XG4gICAgbGV0IHNjaGVtYSA9IHRoaXM7XG4gICAgaWYgKHNjaGVtYS5jb25kaXRpb25zLmxlbmd0aCkge1xuICAgICAgbGV0IGNvbmRpdGlvbnMgPSBzY2hlbWEuY29uZGl0aW9ucztcbiAgICAgIHNjaGVtYSA9IHNjaGVtYS5jbG9uZSgpO1xuICAgICAgc2NoZW1hLmNvbmRpdGlvbnMgPSBbXTtcbiAgICAgIHNjaGVtYSA9IGNvbmRpdGlvbnMucmVkdWNlKChwcmV2U2NoZW1hLCBjb25kaXRpb24pID0+IGNvbmRpdGlvbi5yZXNvbHZlKHByZXZTY2hlbWEsIG9wdGlvbnMpLCBzY2hlbWEpO1xuICAgICAgc2NoZW1hID0gc2NoZW1hLnJlc29sdmUob3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBzY2hlbWE7XG4gIH1cbiAgcmVzb2x2ZU9wdGlvbnMob3B0aW9ucykge1xuICAgIHZhciBfb3B0aW9ucyRzdHJpY3QsIF9vcHRpb25zJGFib3J0RWFybHksIF9vcHRpb25zJHJlY3Vyc2l2ZSwgX29wdGlvbnMkZGlzYWJsZVN0YWNrO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICBmcm9tOiBvcHRpb25zLmZyb20gfHwgW10sXG4gICAgICBzdHJpY3Q6IChfb3B0aW9ucyRzdHJpY3QgPSBvcHRpb25zLnN0cmljdCkgIT0gbnVsbCA/IF9vcHRpb25zJHN0cmljdCA6IHRoaXMuc3BlYy5zdHJpY3QsXG4gICAgICBhYm9ydEVhcmx5OiAoX29wdGlvbnMkYWJvcnRFYXJseSA9IG9wdGlvbnMuYWJvcnRFYXJseSkgIT0gbnVsbCA/IF9vcHRpb25zJGFib3J0RWFybHkgOiB0aGlzLnNwZWMuYWJvcnRFYXJseSxcbiAgICAgIHJlY3Vyc2l2ZTogKF9vcHRpb25zJHJlY3Vyc2l2ZSA9IG9wdGlvbnMucmVjdXJzaXZlKSAhPSBudWxsID8gX29wdGlvbnMkcmVjdXJzaXZlIDogdGhpcy5zcGVjLnJlY3Vyc2l2ZSxcbiAgICAgIGRpc2FibGVTdGFja1RyYWNlOiAoX29wdGlvbnMkZGlzYWJsZVN0YWNrID0gb3B0aW9ucy5kaXNhYmxlU3RhY2tUcmFjZSkgIT0gbnVsbCA/IF9vcHRpb25zJGRpc2FibGVTdGFjayA6IHRoaXMuc3BlYy5kaXNhYmxlU3RhY2tUcmFjZVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1biB0aGUgY29uZmlndXJlZCB0cmFuc2Zvcm0gcGlwZWxpbmUgb3ZlciBhbiBpbnB1dCB2YWx1ZS5cbiAgICovXG5cbiAgY2FzdCh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IHJlc29sdmVkU2NoZW1hID0gdGhpcy5yZXNvbHZlKE9iamVjdC5hc3NpZ24oe1xuICAgICAgdmFsdWVcbiAgICB9LCBvcHRpb25zKSk7XG4gICAgbGV0IGFsbG93T3B0aW9uYWxpdHkgPSBvcHRpb25zLmFzc2VydCA9PT0gJ2lnbm9yZS1vcHRpb25hbGl0eSc7XG4gICAgbGV0IHJlc3VsdCA9IHJlc29sdmVkU2NoZW1hLl9jYXN0KHZhbHVlLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5hc3NlcnQgIT09IGZhbHNlICYmICFyZXNvbHZlZFNjaGVtYS5pc1R5cGUocmVzdWx0KSkge1xuICAgICAgaWYgKGFsbG93T3B0aW9uYWxpdHkgJiYgaXNBYnNlbnQocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgbGV0IGZvcm1hdHRlZFZhbHVlID0gcHJpbnRWYWx1ZSh2YWx1ZSk7XG4gICAgICBsZXQgZm9ybWF0dGVkUmVzdWx0ID0gcHJpbnRWYWx1ZShyZXN1bHQpO1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIHZhbHVlIG9mICR7b3B0aW9ucy5wYXRoIHx8ICdmaWVsZCd9IGNvdWxkIG5vdCBiZSBjYXN0IHRvIGEgdmFsdWUgYCArIGB0aGF0IHNhdGlzZmllcyB0aGUgc2NoZW1hIHR5cGU6IFwiJHtyZXNvbHZlZFNjaGVtYS50eXBlfVwiLiBcXG5cXG5gICsgYGF0dGVtcHRlZCB2YWx1ZTogJHtmb3JtYXR0ZWRWYWx1ZX0gXFxuYCArIChmb3JtYXR0ZWRSZXN1bHQgIT09IGZvcm1hdHRlZFZhbHVlID8gYHJlc3VsdCBvZiBjYXN0OiAke2Zvcm1hdHRlZFJlc3VsdH1gIDogJycpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBfY2FzdChyYXdWYWx1ZSwgb3B0aW9ucykge1xuICAgIGxldCB2YWx1ZSA9IHJhd1ZhbHVlID09PSB1bmRlZmluZWQgPyByYXdWYWx1ZSA6IHRoaXMudHJhbnNmb3Jtcy5yZWR1Y2UoKHByZXZWYWx1ZSwgZm4pID0+IGZuLmNhbGwodGhpcywgcHJldlZhbHVlLCByYXdWYWx1ZSwgdGhpcyksIHJhd1ZhbHVlKTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsdWUgPSB0aGlzLmdldERlZmF1bHQob3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBfdmFsaWRhdGUoX3ZhbHVlLCBvcHRpb25zID0ge30sIHBhbmljLCBuZXh0KSB7XG4gICAgbGV0IHtcbiAgICAgIHBhdGgsXG4gICAgICBvcmlnaW5hbFZhbHVlID0gX3ZhbHVlLFxuICAgICAgc3RyaWN0ID0gdGhpcy5zcGVjLnN0cmljdFxuICAgIH0gPSBvcHRpb25zO1xuICAgIGxldCB2YWx1ZSA9IF92YWx1ZTtcbiAgICBpZiAoIXN0cmljdCkge1xuICAgICAgdmFsdWUgPSB0aGlzLl9jYXN0KHZhbHVlLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgYXNzZXJ0OiBmYWxzZVxuICAgICAgfSwgb3B0aW9ucykpO1xuICAgIH1cbiAgICBsZXQgaW5pdGlhbFRlc3RzID0gW107XG4gICAgZm9yIChsZXQgdGVzdCBvZiBPYmplY3QudmFsdWVzKHRoaXMuaW50ZXJuYWxUZXN0cykpIHtcbiAgICAgIGlmICh0ZXN0KSBpbml0aWFsVGVzdHMucHVzaCh0ZXN0KTtcbiAgICB9XG4gICAgdGhpcy5ydW5UZXN0cyh7XG4gICAgICBwYXRoLFxuICAgICAgdmFsdWUsXG4gICAgICBvcmlnaW5hbFZhbHVlLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIHRlc3RzOiBpbml0aWFsVGVzdHNcbiAgICB9LCBwYW5pYywgaW5pdGlhbEVycm9ycyA9PiB7XG4gICAgICAvLyBldmVuIGlmIHdlIGFyZW4ndCBlbmRpbmcgZWFybHkgd2UgY2FuJ3QgcHJvY2VlZCBmdXJ0aGVyIGlmIHRoZSB0eXBlcyBhcmVuJ3QgY29ycmVjdFxuICAgICAgaWYgKGluaXRpYWxFcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXh0KGluaXRpYWxFcnJvcnMsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucnVuVGVzdHMoe1xuICAgICAgICBwYXRoLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgb3JpZ2luYWxWYWx1ZSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgdGVzdHM6IHRoaXMudGVzdHNcbiAgICAgIH0sIHBhbmljLCBuZXh0KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhIHNldCBvZiB2YWxpZGF0aW9ucywgZWl0aGVyIHNjaGVtYSwgcHJvZHVjZWQgVGVzdHMgb3IgYSBuZXN0ZWRcbiAgICogc2NoZW1hIHZhbGlkYXRlIHJlc3VsdC5cbiAgICovXG4gIHJ1blRlc3RzKHJ1bk9wdGlvbnMsIHBhbmljLCBuZXh0KSB7XG4gICAgbGV0IGZpcmVkID0gZmFsc2U7XG4gICAgbGV0IHtcbiAgICAgIHRlc3RzLFxuICAgICAgdmFsdWUsXG4gICAgICBvcmlnaW5hbFZhbHVlLFxuICAgICAgcGF0aCxcbiAgICAgIG9wdGlvbnNcbiAgICB9ID0gcnVuT3B0aW9ucztcbiAgICBsZXQgcGFuaWNPbmNlID0gYXJnID0+IHtcbiAgICAgIGlmIChmaXJlZCkgcmV0dXJuO1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgcGFuaWMoYXJnLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBsZXQgbmV4dE9uY2UgPSBhcmcgPT4ge1xuICAgICAgaWYgKGZpcmVkKSByZXR1cm47XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBuZXh0KGFyZywgdmFsdWUpO1xuICAgIH07XG4gICAgbGV0IGNvdW50ID0gdGVzdHMubGVuZ3RoO1xuICAgIGxldCBuZXN0ZWRFcnJvcnMgPSBbXTtcbiAgICBpZiAoIWNvdW50KSByZXR1cm4gbmV4dE9uY2UoW10pO1xuICAgIGxldCBhcmdzID0ge1xuICAgICAgdmFsdWUsXG4gICAgICBvcmlnaW5hbFZhbHVlLFxuICAgICAgcGF0aCxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBzY2hlbWE6IHRoaXNcbiAgICB9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVzdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRlc3QgPSB0ZXN0c1tpXTtcbiAgICAgIHRlc3QoYXJncywgcGFuaWNPbmNlLCBmdW5jdGlvbiBmaW5pc2hUZXN0UnVuKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgQXJyYXkuaXNBcnJheShlcnIpID8gbmVzdGVkRXJyb3JzLnB1c2goLi4uZXJyKSA6IG5lc3RlZEVycm9ycy5wdXNoKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKC0tY291bnQgPD0gMCkge1xuICAgICAgICAgIG5leHRPbmNlKG5lc3RlZEVycm9ycyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBhc05lc3RlZFRlc3Qoe1xuICAgIGtleSxcbiAgICBpbmRleCxcbiAgICBwYXJlbnQsXG4gICAgcGFyZW50UGF0aCxcbiAgICBvcmlnaW5hbFBhcmVudCxcbiAgICBvcHRpb25zXG4gIH0pIHtcbiAgICBjb25zdCBrID0ga2V5ICE9IG51bGwgPyBrZXkgOiBpbmRleDtcbiAgICBpZiAoayA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ011c3QgaW5jbHVkZSBga2V5YCBvciBgaW5kZXhgIGZvciBuZXN0ZWQgdmFsaWRhdGlvbnMnKTtcbiAgICB9XG4gICAgY29uc3QgaXNJbmRleCA9IHR5cGVvZiBrID09PSAnbnVtYmVyJztcbiAgICBsZXQgdmFsdWUgPSBwYXJlbnRba107XG4gICAgY29uc3QgdGVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICAvLyBOZXN0ZWQgdmFsaWRhdGlvbnMgZmllbGRzIGFyZSBhbHdheXMgc3RyaWN0OlxuICAgICAgLy8gICAgMS4gcGFyZW50IGlzbid0IHN0cmljdCBzbyB0aGUgY2FzdGluZyB3aWxsIGFsc28gaGF2ZSBjYXN0IGlubmVyIHZhbHVlc1xuICAgICAgLy8gICAgMi4gcGFyZW50IGlzIHN0cmljdCBpbiB3aGljaCBjYXNlIHRoZSBuZXN0ZWQgdmFsdWVzIHdlcmVuJ3QgY2FzdCBlaXRoZXJcbiAgICAgIHN0cmljdDogdHJ1ZSxcbiAgICAgIHBhcmVudCxcbiAgICAgIHZhbHVlLFxuICAgICAgb3JpZ2luYWxWYWx1ZTogb3JpZ2luYWxQYXJlbnRba10sXG4gICAgICAvLyBGSVhNRTogdGVzdHMgZGVwZW5kIG9uIGBpbmRleGAgYmVpbmcgcGFzc2VkIGFyb3VuZCBkZWVwbHksXG4gICAgICAvLyAgIHdlIHNob3VsZCBub3QgbGV0IHRoZSBvcHRpb25zLmtleS9pbmRleCBibGVlZCB0aHJvdWdoXG4gICAgICBrZXk6IHVuZGVmaW5lZCxcbiAgICAgIC8vIGluZGV4OiB1bmRlZmluZWQsXG4gICAgICBbaXNJbmRleCA/ICdpbmRleCcgOiAna2V5J106IGssXG4gICAgICBwYXRoOiBpc0luZGV4IHx8IGsuaW5jbHVkZXMoJy4nKSA/IGAke3BhcmVudFBhdGggfHwgJyd9WyR7aXNJbmRleCA/IGsgOiBgXCIke2t9XCJgfV1gIDogKHBhcmVudFBhdGggPyBgJHtwYXJlbnRQYXRofS5gIDogJycpICsga2V5XG4gICAgfSk7XG4gICAgcmV0dXJuIChfLCBwYW5pYywgbmV4dCkgPT4gdGhpcy5yZXNvbHZlKHRlc3RPcHRpb25zKS5fdmFsaWRhdGUodmFsdWUsIHRlc3RPcHRpb25zLCBwYW5pYywgbmV4dCk7XG4gIH1cbiAgdmFsaWRhdGUodmFsdWUsIG9wdGlvbnMpIHtcbiAgICB2YXIgX29wdGlvbnMkZGlzYWJsZVN0YWNrMjtcbiAgICBsZXQgc2NoZW1hID0gdGhpcy5yZXNvbHZlKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgIHZhbHVlXG4gICAgfSkpO1xuICAgIGxldCBkaXNhYmxlU3RhY2tUcmFjZSA9IChfb3B0aW9ucyRkaXNhYmxlU3RhY2syID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5kaXNhYmxlU3RhY2tUcmFjZSkgIT0gbnVsbCA/IF9vcHRpb25zJGRpc2FibGVTdGFjazIgOiBzY2hlbWEuc3BlYy5kaXNhYmxlU3RhY2tUcmFjZTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gc2NoZW1hLl92YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucywgKGVycm9yLCBwYXJzZWQpID0+IHtcbiAgICAgIGlmIChWYWxpZGF0aW9uRXJyb3IuaXNFcnJvcihlcnJvcikpIGVycm9yLnZhbHVlID0gcGFyc2VkO1xuICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICB9LCAoZXJyb3JzLCB2YWxpZGF0ZWQpID0+IHtcbiAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSByZWplY3QobmV3IFZhbGlkYXRpb25FcnJvcihlcnJvcnMsIHZhbGlkYXRlZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRpc2FibGVTdGFja1RyYWNlKSk7ZWxzZSByZXNvbHZlKHZhbGlkYXRlZCk7XG4gICAgfSkpO1xuICB9XG4gIHZhbGlkYXRlU3luYyh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHZhciBfb3B0aW9ucyRkaXNhYmxlU3RhY2szO1xuICAgIGxldCBzY2hlbWEgPSB0aGlzLnJlc29sdmUoT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgdmFsdWVcbiAgICB9KSk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBsZXQgZGlzYWJsZVN0YWNrVHJhY2UgPSAoX29wdGlvbnMkZGlzYWJsZVN0YWNrMyA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZGlzYWJsZVN0YWNrVHJhY2UpICE9IG51bGwgPyBfb3B0aW9ucyRkaXNhYmxlU3RhY2szIDogc2NoZW1hLnNwZWMuZGlzYWJsZVN0YWNrVHJhY2U7XG4gICAgc2NoZW1hLl92YWxpZGF0ZSh2YWx1ZSwgT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgc3luYzogdHJ1ZVxuICAgIH0pLCAoZXJyb3IsIHBhcnNlZCkgPT4ge1xuICAgICAgaWYgKFZhbGlkYXRpb25FcnJvci5pc0Vycm9yKGVycm9yKSkgZXJyb3IudmFsdWUgPSBwYXJzZWQ7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9LCAoZXJyb3JzLCB2YWxpZGF0ZWQpID0+IHtcbiAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGVycm9ycywgdmFsdWUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkaXNhYmxlU3RhY2tUcmFjZSk7XG4gICAgICByZXN1bHQgPSB2YWxpZGF0ZWQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpc1ZhbGlkKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdGUodmFsdWUsIG9wdGlvbnMpLnRoZW4oKCkgPT4gdHJ1ZSwgZXJyID0+IHtcbiAgICAgIGlmIChWYWxpZGF0aW9uRXJyb3IuaXNFcnJvcihlcnIpKSByZXR1cm4gZmFsc2U7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSk7XG4gIH1cbiAgaXNWYWxpZFN5bmModmFsdWUsIG9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy52YWxpZGF0ZVN5bmModmFsdWUsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoVmFsaWRhdGlvbkVycm9yLmlzRXJyb3IoZXJyKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuICBfZ2V0RGVmYXVsdChvcHRpb25zKSB7XG4gICAgbGV0IGRlZmF1bHRWYWx1ZSA9IHRoaXMuc3BlYy5kZWZhdWx0O1xuICAgIGlmIChkZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiBkZWZhdWx0VmFsdWUgPT09ICdmdW5jdGlvbicgPyBkZWZhdWx0VmFsdWUuY2FsbCh0aGlzLCBvcHRpb25zKSA6IGNsb25lKGRlZmF1bHRWYWx1ZSk7XG4gIH1cbiAgZ2V0RGVmYXVsdChvcHRpb25zXG4gIC8vIElmIHNjaGVtYSBpcyBkZWZhdWx0ZWQgd2Uga25vdyBpdCdzIGF0IGxlYXN0IG5vdCB1bmRlZmluZWRcbiAgKSB7XG4gICAgbGV0IHNjaGVtYSA9IHRoaXMucmVzb2x2ZShvcHRpb25zIHx8IHt9KTtcbiAgICByZXR1cm4gc2NoZW1hLl9nZXREZWZhdWx0KG9wdGlvbnMpO1xuICB9XG4gIGRlZmF1bHQoZGVmKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXREZWZhdWx0KCk7XG4gICAgfVxuICAgIGxldCBuZXh0ID0gdGhpcy5jbG9uZSh7XG4gICAgICBkZWZhdWx0OiBkZWZcbiAgICB9KTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICBzdHJpY3QoaXNTdHJpY3QgPSB0cnVlKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoe1xuICAgICAgc3RyaWN0OiBpc1N0cmljdFxuICAgIH0pO1xuICB9XG4gIG51bGxhYmlsaXR5KG51bGxhYmxlLCBtZXNzYWdlKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuY2xvbmUoe1xuICAgICAgbnVsbGFibGVcbiAgICB9KTtcbiAgICBuZXh0LmludGVybmFsVGVzdHMubnVsbGFibGUgPSBjcmVhdGVWYWxpZGF0aW9uKHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAnbnVsbGFibGUnLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyB0aGlzLnNjaGVtYS5zcGVjLm51bGxhYmxlIDogdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICBvcHRpb25hbGl0eShvcHRpb25hbCwgbWVzc2FnZSkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmNsb25lKHtcbiAgICAgIG9wdGlvbmFsXG4gICAgfSk7XG4gICAgbmV4dC5pbnRlcm5hbFRlc3RzLm9wdGlvbmFsaXR5ID0gY3JlYXRlVmFsaWRhdGlvbih7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ29wdGlvbmFsaXR5JyxcbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB0aGlzLnNjaGVtYS5zcGVjLm9wdGlvbmFsIDogdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICBvcHRpb25hbCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25hbGl0eSh0cnVlKTtcbiAgfVxuICBkZWZpbmVkKG1lc3NhZ2UgPSBtaXhlZC5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9uYWxpdHkoZmFsc2UsIG1lc3NhZ2UpO1xuICB9XG4gIG51bGxhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLm51bGxhYmlsaXR5KHRydWUpO1xuICB9XG4gIG5vbk51bGxhYmxlKG1lc3NhZ2UgPSBtaXhlZC5ub3ROdWxsKSB7XG4gICAgcmV0dXJuIHRoaXMubnVsbGFiaWxpdHkoZmFsc2UsIG1lc3NhZ2UpO1xuICB9XG4gIHJlcXVpcmVkKG1lc3NhZ2UgPSBtaXhlZC5yZXF1aXJlZCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkud2l0aE11dGF0aW9uKG5leHQgPT4gbmV4dC5ub25OdWxsYWJsZShtZXNzYWdlKS5kZWZpbmVkKG1lc3NhZ2UpKTtcbiAgfVxuICBub3RSZXF1aXJlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLndpdGhNdXRhdGlvbihuZXh0ID0+IG5leHQubnVsbGFibGUoKS5vcHRpb25hbCgpKTtcbiAgfVxuICB0cmFuc2Zvcm0oZm4pIHtcbiAgICBsZXQgbmV4dCA9IHRoaXMuY2xvbmUoKTtcbiAgICBuZXh0LnRyYW5zZm9ybXMucHVzaChmbik7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIHRlc3QgZnVuY3Rpb24gdG8gdGhlIHNjaGVtYSdzIHF1ZXVlIG9mIHRlc3RzLlxuICAgKiB0ZXN0cyBjYW4gYmUgZXhjbHVzaXZlIG9yIG5vbi1leGNsdXNpdmUuXG4gICAqXG4gICAqIC0gZXhjbHVzaXZlIHRlc3RzLCB3aWxsIHJlcGxhY2UgYW55IGV4aXN0aW5nIHRlc3RzIG9mIHRoZSBzYW1lIG5hbWUuXG4gICAqIC0gbm9uLWV4Y2x1c2l2ZTogY2FuIGJlIHN0YWNrZWRcbiAgICpcbiAgICogSWYgYSBub24tZXhjbHVzaXZlIHRlc3QgaXMgYWRkZWQgdG8gYSBzY2hlbWEgd2l0aCBhbiBleGNsdXNpdmUgdGVzdCBvZiB0aGUgc2FtZSBuYW1lXG4gICAqIHRoZSBleGNsdXNpdmUgdGVzdCBpcyByZW1vdmVkIGFuZCBmdXJ0aGVyIHRlc3RzIG9mIHRoZSBzYW1lIG5hbWUgd2lsbCBiZSBzdGFja2VkLlxuICAgKlxuICAgKiBJZiBhbiBleGNsdXNpdmUgdGVzdCBpcyBhZGRlZCB0byBhIHNjaGVtYSB3aXRoIG5vbi1leGNsdXNpdmUgdGVzdHMgb2YgdGhlIHNhbWUgbmFtZVxuICAgKiB0aGUgcHJldmlvdXMgdGVzdHMgYXJlIHJlbW92ZWQgYW5kIGZ1cnRoZXIgdGVzdHMgb2YgdGhlIHNhbWUgbmFtZSB3aWxsIHJlcGxhY2UgZWFjaCBvdGhlci5cbiAgICovXG5cbiAgdGVzdCguLi5hcmdzKSB7XG4gICAgbGV0IG9wdHM7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb3B0cyA9IHtcbiAgICAgICAgICB0ZXN0OiBhcmdzWzBdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRzID0gYXJnc1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICBvcHRzID0ge1xuICAgICAgICBuYW1lOiBhcmdzWzBdLFxuICAgICAgICB0ZXN0OiBhcmdzWzFdXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRzID0ge1xuICAgICAgICBuYW1lOiBhcmdzWzBdLFxuICAgICAgICBtZXNzYWdlOiBhcmdzWzFdLFxuICAgICAgICB0ZXN0OiBhcmdzWzJdXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAob3B0cy5tZXNzYWdlID09PSB1bmRlZmluZWQpIG9wdHMubWVzc2FnZSA9IG1peGVkLmRlZmF1bHQ7XG4gICAgaWYgKHR5cGVvZiBvcHRzLnRlc3QgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2B0ZXN0YCBpcyBhIHJlcXVpcmVkIHBhcmFtZXRlcnMnKTtcbiAgICBsZXQgbmV4dCA9IHRoaXMuY2xvbmUoKTtcbiAgICBsZXQgdmFsaWRhdGUgPSBjcmVhdGVWYWxpZGF0aW9uKG9wdHMpO1xuICAgIGxldCBpc0V4Y2x1c2l2ZSA9IG9wdHMuZXhjbHVzaXZlIHx8IG9wdHMubmFtZSAmJiBuZXh0LmV4Y2x1c2l2ZVRlc3RzW29wdHMubmFtZV0gPT09IHRydWU7XG4gICAgaWYgKG9wdHMuZXhjbHVzaXZlKSB7XG4gICAgICBpZiAoIW9wdHMubmFtZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhjbHVzaXZlIHRlc3RzIG11c3QgcHJvdmlkZSBhIHVuaXF1ZSBgbmFtZWAgaWRlbnRpZnlpbmcgdGhlIHRlc3QnKTtcbiAgICB9XG4gICAgaWYgKG9wdHMubmFtZSkgbmV4dC5leGNsdXNpdmVUZXN0c1tvcHRzLm5hbWVdID0gISFvcHRzLmV4Y2x1c2l2ZTtcbiAgICBuZXh0LnRlc3RzID0gbmV4dC50ZXN0cy5maWx0ZXIoZm4gPT4ge1xuICAgICAgaWYgKGZuLk9QVElPTlMubmFtZSA9PT0gb3B0cy5uYW1lKSB7XG4gICAgICAgIGlmIChpc0V4Y2x1c2l2ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZm4uT1BUSU9OUy50ZXN0ID09PSB2YWxpZGF0ZS5PUFRJT05TLnRlc3QpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIG5leHQudGVzdHMucHVzaCh2YWxpZGF0ZSk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgd2hlbihrZXlzLCBvcHRpb25zKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGtleXMpICYmIHR5cGVvZiBrZXlzICE9PSAnc3RyaW5nJykge1xuICAgICAgb3B0aW9ucyA9IGtleXM7XG4gICAgICBrZXlzID0gJy4nO1xuICAgIH1cbiAgICBsZXQgbmV4dCA9IHRoaXMuY2xvbmUoKTtcbiAgICBsZXQgZGVwcyA9IHRvQXJyYXkoa2V5cykubWFwKGtleSA9PiBuZXcgUmVmZXJlbmNlKGtleSkpO1xuICAgIGRlcHMuZm9yRWFjaChkZXAgPT4ge1xuICAgICAgLy8gQHRzLWlnbm9yZSByZWFkb25seSBhcnJheVxuICAgICAgaWYgKGRlcC5pc1NpYmxpbmcpIG5leHQuZGVwcy5wdXNoKGRlcC5rZXkpO1xuICAgIH0pO1xuICAgIG5leHQuY29uZGl0aW9ucy5wdXNoKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nID8gbmV3IENvbmRpdGlvbihkZXBzLCBvcHRpb25zKSA6IENvbmRpdGlvbi5mcm9tT3B0aW9ucyhkZXBzLCBvcHRpb25zKSk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgdHlwZUVycm9yKG1lc3NhZ2UpIHtcbiAgICBsZXQgbmV4dCA9IHRoaXMuY2xvbmUoKTtcbiAgICBuZXh0LmludGVybmFsVGVzdHMudHlwZUVycm9yID0gY3JlYXRlVmFsaWRhdGlvbih7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ3R5cGVFcnJvcicsXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuc2NoZW1hLl90eXBlQ2hlY2sodmFsdWUpKSByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcih7XG4gICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICB0eXBlOiB0aGlzLnNjaGVtYS50eXBlXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgb25lT2YoZW51bXMsIG1lc3NhZ2UgPSBtaXhlZC5vbmVPZikge1xuICAgIGxldCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xuICAgIGVudW1zLmZvckVhY2godmFsID0+IHtcbiAgICAgIG5leHQuX3doaXRlbGlzdC5hZGQodmFsKTtcbiAgICAgIG5leHQuX2JsYWNrbGlzdC5kZWxldGUodmFsKTtcbiAgICB9KTtcbiAgICBuZXh0LmludGVybmFsVGVzdHMud2hpdGVMaXN0ID0gY3JlYXRlVmFsaWRhdGlvbih7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ29uZU9mJyxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIGxldCB2YWxpZHMgPSB0aGlzLnNjaGVtYS5fd2hpdGVsaXN0O1xuICAgICAgICBsZXQgcmVzb2x2ZWQgPSB2YWxpZHMucmVzb2x2ZUFsbCh0aGlzLnJlc29sdmUpO1xuICAgICAgICByZXR1cm4gcmVzb2x2ZWQuaW5jbHVkZXModmFsdWUpID8gdHJ1ZSA6IHRoaXMuY3JlYXRlRXJyb3Ioe1xuICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgdmFsdWVzOiBBcnJheS5mcm9tKHZhbGlkcykuam9pbignLCAnKSxcbiAgICAgICAgICAgIHJlc29sdmVkXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICBub3RPbmVPZihlbnVtcywgbWVzc2FnZSA9IG1peGVkLm5vdE9uZU9mKSB7XG4gICAgbGV0IG5leHQgPSB0aGlzLmNsb25lKCk7XG4gICAgZW51bXMuZm9yRWFjaCh2YWwgPT4ge1xuICAgICAgbmV4dC5fYmxhY2tsaXN0LmFkZCh2YWwpO1xuICAgICAgbmV4dC5fd2hpdGVsaXN0LmRlbGV0ZSh2YWwpO1xuICAgIH0pO1xuICAgIG5leHQuaW50ZXJuYWxUZXN0cy5ibGFja2xpc3QgPSBjcmVhdGVWYWxpZGF0aW9uKHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAnbm90T25lT2YnLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICBsZXQgaW52YWxpZHMgPSB0aGlzLnNjaGVtYS5fYmxhY2tsaXN0O1xuICAgICAgICBsZXQgcmVzb2x2ZWQgPSBpbnZhbGlkcy5yZXNvbHZlQWxsKHRoaXMucmVzb2x2ZSk7XG4gICAgICAgIGlmIChyZXNvbHZlZC5pbmNsdWRlcyh2YWx1ZSkpIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKHtcbiAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIHZhbHVlczogQXJyYXkuZnJvbShpbnZhbGlkcykuam9pbignLCAnKSxcbiAgICAgICAgICAgIHJlc29sdmVkXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgc3RyaXAoc3RyaXAgPSB0cnVlKSB7XG4gICAgbGV0IG5leHQgPSB0aGlzLmNsb25lKCk7XG4gICAgbmV4dC5zcGVjLnN0cmlwID0gc3RyaXA7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgc2VyaWFsaXplZCBkZXNjcmlwdGlvbiBvZiB0aGUgc2NoZW1hIGluY2x1ZGluZyB2YWxpZGF0aW9ucywgZmxhZ3MsIHR5cGVzIGV0Yy5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgUHJvdmlkZSBhbnkgbmVlZGVkIGNvbnRleHQgZm9yIHJlc29sdmluZyBydW50aW1lIHNjaGVtYSBhbHRlcmF0aW9ucyAobGF6eSwgd2hlbiBjb25kaXRpb25zLCBldGMpLlxuICAgKi9cbiAgZGVzY3JpYmUob3B0aW9ucykge1xuICAgIGNvbnN0IG5leHQgPSAob3B0aW9ucyA/IHRoaXMucmVzb2x2ZShvcHRpb25zKSA6IHRoaXMpLmNsb25lKCk7XG4gICAgY29uc3Qge1xuICAgICAgbGFiZWwsXG4gICAgICBtZXRhLFxuICAgICAgb3B0aW9uYWwsXG4gICAgICBudWxsYWJsZVxuICAgIH0gPSBuZXh0LnNwZWM7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSB7XG4gICAgICBtZXRhLFxuICAgICAgbGFiZWwsXG4gICAgICBvcHRpb25hbCxcbiAgICAgIG51bGxhYmxlLFxuICAgICAgZGVmYXVsdDogbmV4dC5nZXREZWZhdWx0KG9wdGlvbnMpLFxuICAgICAgdHlwZTogbmV4dC50eXBlLFxuICAgICAgb25lT2Y6IG5leHQuX3doaXRlbGlzdC5kZXNjcmliZSgpLFxuICAgICAgbm90T25lT2Y6IG5leHQuX2JsYWNrbGlzdC5kZXNjcmliZSgpLFxuICAgICAgdGVzdHM6IG5leHQudGVzdHMubWFwKGZuID0+ICh7XG4gICAgICAgIG5hbWU6IGZuLk9QVElPTlMubmFtZSxcbiAgICAgICAgcGFyYW1zOiBmbi5PUFRJT05TLnBhcmFtc1xuICAgICAgfSkpLmZpbHRlcigobiwgaWR4LCBsaXN0KSA9PiBsaXN0LmZpbmRJbmRleChjID0+IGMubmFtZSA9PT0gbi5uYW1lKSA9PT0gaWR4KVxuICAgIH07XG4gICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICB9XG59XG4vLyBAdHMtZXhwZWN0LWVycm9yXG5TY2hlbWEucHJvdG90eXBlLl9faXNZdXBTY2hlbWFfXyA9IHRydWU7XG5mb3IgKGNvbnN0IG1ldGhvZCBvZiBbJ3ZhbGlkYXRlJywgJ3ZhbGlkYXRlU3luYyddKSBTY2hlbWEucHJvdG90eXBlW2Ake21ldGhvZH1BdGBdID0gZnVuY3Rpb24gKHBhdGgsIHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHBhcmVudCxcbiAgICBwYXJlbnRQYXRoLFxuICAgIHNjaGVtYVxuICB9ID0gZ2V0SW4odGhpcywgcGF0aCwgdmFsdWUsIG9wdGlvbnMuY29udGV4dCk7XG4gIHJldHVybiBzY2hlbWFbbWV0aG9kXShwYXJlbnQgJiYgcGFyZW50W3BhcmVudFBhdGhdLCBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgcGFyZW50LFxuICAgIHBhdGhcbiAgfSkpO1xufTtcbmZvciAoY29uc3QgYWxpYXMgb2YgWydlcXVhbHMnLCAnaXMnXSkgU2NoZW1hLnByb3RvdHlwZVthbGlhc10gPSBTY2hlbWEucHJvdG90eXBlLm9uZU9mO1xuZm9yIChjb25zdCBhbGlhcyBvZiBbJ25vdCcsICdub3BlJ10pIFNjaGVtYS5wcm90b3R5cGVbYWxpYXNdID0gU2NoZW1hLnByb3RvdHlwZS5ub3RPbmVPZjtcblxuY29uc3QgcmV0dXJuc1RydWUgPSAoKSA9PiB0cnVlO1xuZnVuY3Rpb24gY3JlYXRlJDgoc3BlYykge1xuICByZXR1cm4gbmV3IE1peGVkU2NoZW1hKHNwZWMpO1xufVxuY2xhc3MgTWl4ZWRTY2hlbWEgZXh0ZW5kcyBTY2hlbWEge1xuICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgc3VwZXIodHlwZW9mIHNwZWMgPT09ICdmdW5jdGlvbicgPyB7XG4gICAgICB0eXBlOiAnbWl4ZWQnLFxuICAgICAgY2hlY2s6IHNwZWNcbiAgICB9IDogT2JqZWN0LmFzc2lnbih7XG4gICAgICB0eXBlOiAnbWl4ZWQnLFxuICAgICAgY2hlY2s6IHJldHVybnNUcnVlXG4gICAgfSwgc3BlYykpO1xuICB9XG59XG5jcmVhdGUkOC5wcm90b3R5cGUgPSBNaXhlZFNjaGVtYS5wcm90b3R5cGU7XG5cbmZ1bmN0aW9uIGNyZWF0ZSQ3KCkge1xuICByZXR1cm4gbmV3IEJvb2xlYW5TY2hlbWEoKTtcbn1cbmNsYXNzIEJvb2xlYW5TY2hlbWEgZXh0ZW5kcyBTY2hlbWEge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICBjaGVjayh2KSB7XG4gICAgICAgIGlmICh2IGluc3RhbmNlb2YgQm9vbGVhbikgdiA9IHYudmFsdWVPZigpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHYgPT09ICdib29sZWFuJztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLndpdGhNdXRhdGlvbigoKSA9PiB7XG4gICAgICB0aGlzLnRyYW5zZm9ybSgodmFsdWUsIF9yYXcsIGN0eCkgPT4ge1xuICAgICAgICBpZiAoY3R4LnNwZWMuY29lcmNlICYmICFjdHguaXNUeXBlKHZhbHVlKSkge1xuICAgICAgICAgIGlmICgvXih0cnVlfDEpJC9pLnRlc3QoU3RyaW5nKHZhbHVlKSkpIHJldHVybiB0cnVlO1xuICAgICAgICAgIGlmICgvXihmYWxzZXwwKSQvaS50ZXN0KFN0cmluZyh2YWx1ZSkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgaXNUcnVlKG1lc3NhZ2UgPSBib29sZWFuLmlzVmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAnaXMtdmFsdWUnLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHZhbHVlOiAndHJ1ZSdcbiAgICAgIH0sXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpc0Fic2VudCh2YWx1ZSkgfHwgdmFsdWUgPT09IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgaXNGYWxzZShtZXNzYWdlID0gYm9vbGVhbi5pc1ZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ2lzLXZhbHVlJyxcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICB2YWx1ZTogJ2ZhbHNlJ1xuICAgICAgfSxcbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzQWJzZW50KHZhbHVlKSB8fCB2YWx1ZSA9PT0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZGVmYXVsdChkZWYpIHtcbiAgICByZXR1cm4gc3VwZXIuZGVmYXVsdChkZWYpO1xuICB9XG4gIGRlZmluZWQobXNnKSB7XG4gICAgcmV0dXJuIHN1cGVyLmRlZmluZWQobXNnKTtcbiAgfVxuICBvcHRpb25hbCgpIHtcbiAgICByZXR1cm4gc3VwZXIub3B0aW9uYWwoKTtcbiAgfVxuICByZXF1aXJlZChtc2cpIHtcbiAgICByZXR1cm4gc3VwZXIucmVxdWlyZWQobXNnKTtcbiAgfVxuICBub3RSZXF1aXJlZCgpIHtcbiAgICByZXR1cm4gc3VwZXIubm90UmVxdWlyZWQoKTtcbiAgfVxuICBudWxsYWJsZSgpIHtcbiAgICByZXR1cm4gc3VwZXIubnVsbGFibGUoKTtcbiAgfVxuICBub25OdWxsYWJsZShtc2cpIHtcbiAgICByZXR1cm4gc3VwZXIubm9uTnVsbGFibGUobXNnKTtcbiAgfVxuICBzdHJpcCh2KSB7XG4gICAgcmV0dXJuIHN1cGVyLnN0cmlwKHYpO1xuICB9XG59XG5jcmVhdGUkNy5wcm90b3R5cGUgPSBCb29sZWFuU2NoZW1hLnByb3RvdHlwZTtcblxuLyoqXG4gKiBUaGlzIGZpbGUgaXMgYSBtb2RpZmllZCB2ZXJzaW9uIG9mIHRoZSBmaWxlIGZyb20gdGhlIGZvbGxvd2luZyByZXBvc2l0b3J5OlxuICogRGF0ZS5wYXJzZSB3aXRoIHByb2dyZXNzaXZlIGVuaGFuY2VtZW50IGZvciBJU08gODYwMSA8aHR0cHM6Ly9naXRodWIuY29tL2Nzbm92ZXIvanMtaXNvODYwMT5cbiAqIE5PTi1DT05GT1JNQU5UIEVESVRJT04uXG4gKiDCqSAyMDExIENvbGluIFNub3ZlciA8aHR0cDovL3pldGFmbGVldC5jb20+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqL1xuXG4vLyBwcmV0dGllci1pZ25vcmVcbi8vICAgICAgICAgICAgICAgIDEgWVlZWSAgICAgICAgICAgICAgICAyIE1NICAgICAgICAzIEREICAgICAgICAgICAgICA0IEhIICAgICA1IG1tICAgICAgICA2IHNzICAgICAgICAgICA3IG1zZWMgICAgICAgICA4IFogOSDCsSAgIDEwIHR6SEggICAgMTEgdHptbVxuY29uc3QgaXNvUmVnID0gL14oXFxkezR9fFsrLV1cXGR7Nn0pKD86LT8oXFxkezJ9KSg/Oi0/KFxcZHsyfSkpPyk/KD86WyBUXT8oXFxkezJ9KTo/KFxcZHsyfSkoPzo6PyhcXGR7Mn0pKD86WywuXShcXGR7MSx9KSk/KT8oPzooWil8KFsrLV0pKFxcZHsyfSkoPzo6PyhcXGR7Mn0pKT8pPyk/JC87XG5mdW5jdGlvbiBwYXJzZUlzb0RhdGUoZGF0ZSkge1xuICBjb25zdCBzdHJ1Y3QgPSBwYXJzZURhdGVTdHJ1Y3QoZGF0ZSk7XG4gIGlmICghc3RydWN0KSByZXR1cm4gRGF0ZS5wYXJzZSA/IERhdGUucGFyc2UoZGF0ZSkgOiBOdW1iZXIuTmFOO1xuXG4gIC8vIHRpbWVzdGFtcHMgd2l0aG91dCB0aW1lem9uZSBpZGVudGlmaWVycyBzaG91bGQgYmUgY29uc2lkZXJlZCBsb2NhbCB0aW1lXG4gIGlmIChzdHJ1Y3QueiA9PT0gdW5kZWZpbmVkICYmIHN0cnVjdC5wbHVzTWludXMgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBuZXcgRGF0ZShzdHJ1Y3QueWVhciwgc3RydWN0Lm1vbnRoLCBzdHJ1Y3QuZGF5LCBzdHJ1Y3QuaG91ciwgc3RydWN0Lm1pbnV0ZSwgc3RydWN0LnNlY29uZCwgc3RydWN0Lm1pbGxpc2Vjb25kKS52YWx1ZU9mKCk7XG4gIH1cbiAgbGV0IHRvdGFsTWludXRlc09mZnNldCA9IDA7XG4gIGlmIChzdHJ1Y3QueiAhPT0gJ1onICYmIHN0cnVjdC5wbHVzTWludXMgIT09IHVuZGVmaW5lZCkge1xuICAgIHRvdGFsTWludXRlc09mZnNldCA9IHN0cnVjdC5ob3VyT2Zmc2V0ICogNjAgKyBzdHJ1Y3QubWludXRlT2Zmc2V0O1xuICAgIGlmIChzdHJ1Y3QucGx1c01pbnVzID09PSAnKycpIHRvdGFsTWludXRlc09mZnNldCA9IDAgLSB0b3RhbE1pbnV0ZXNPZmZzZXQ7XG4gIH1cbiAgcmV0dXJuIERhdGUuVVRDKHN0cnVjdC55ZWFyLCBzdHJ1Y3QubW9udGgsIHN0cnVjdC5kYXksIHN0cnVjdC5ob3VyLCBzdHJ1Y3QubWludXRlICsgdG90YWxNaW51dGVzT2Zmc2V0LCBzdHJ1Y3Quc2Vjb25kLCBzdHJ1Y3QubWlsbGlzZWNvbmQpO1xufVxuZnVuY3Rpb24gcGFyc2VEYXRlU3RydWN0KGRhdGUpIHtcbiAgdmFyIF9yZWdleFJlc3VsdCQ3JGxlbmd0aCwgX3JlZ2V4UmVzdWx0JDtcbiAgY29uc3QgcmVnZXhSZXN1bHQgPSBpc29SZWcuZXhlYyhkYXRlKTtcbiAgaWYgKCFyZWdleFJlc3VsdCkgcmV0dXJuIG51bGw7XG5cbiAgLy8gdXNlIG9mIHRvTnVtYmVyKCkgYXZvaWRzIE5hTiB0aW1lc3RhbXBzIGNhdXNlZCBieSDigJx1bmRlZmluZWTigJ1cbiAgLy8gdmFsdWVzIGJlaW5nIHBhc3NlZCB0byBEYXRlIGNvbnN0cnVjdG9yXG4gIHJldHVybiB7XG4gICAgeWVhcjogdG9OdW1iZXIocmVnZXhSZXN1bHRbMV0pLFxuICAgIG1vbnRoOiB0b051bWJlcihyZWdleFJlc3VsdFsyXSwgMSkgLSAxLFxuICAgIGRheTogdG9OdW1iZXIocmVnZXhSZXN1bHRbM10sIDEpLFxuICAgIGhvdXI6IHRvTnVtYmVyKHJlZ2V4UmVzdWx0WzRdKSxcbiAgICBtaW51dGU6IHRvTnVtYmVyKHJlZ2V4UmVzdWx0WzVdKSxcbiAgICBzZWNvbmQ6IHRvTnVtYmVyKHJlZ2V4UmVzdWx0WzZdKSxcbiAgICBtaWxsaXNlY29uZDogcmVnZXhSZXN1bHRbN10gP1xuICAgIC8vIGFsbG93IGFyYml0cmFyeSBzdWItc2Vjb25kIHByZWNpc2lvbiBiZXlvbmQgbWlsbGlzZWNvbmRzXG4gICAgdG9OdW1iZXIocmVnZXhSZXN1bHRbN10uc3Vic3RyaW5nKDAsIDMpKSA6IDAsXG4gICAgcHJlY2lzaW9uOiAoX3JlZ2V4UmVzdWx0JDckbGVuZ3RoID0gKF9yZWdleFJlc3VsdCQgPSByZWdleFJlc3VsdFs3XSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yZWdleFJlc3VsdCQubGVuZ3RoKSAhPSBudWxsID8gX3JlZ2V4UmVzdWx0JDckbGVuZ3RoIDogdW5kZWZpbmVkLFxuICAgIHo6IHJlZ2V4UmVzdWx0WzhdIHx8IHVuZGVmaW5lZCxcbiAgICBwbHVzTWludXM6IHJlZ2V4UmVzdWx0WzldIHx8IHVuZGVmaW5lZCxcbiAgICBob3VyT2Zmc2V0OiB0b051bWJlcihyZWdleFJlc3VsdFsxMF0pLFxuICAgIG1pbnV0ZU9mZnNldDogdG9OdW1iZXIocmVnZXhSZXN1bHRbMTFdKVxuICB9O1xufVxuZnVuY3Rpb24gdG9OdW1iZXIoc3RyLCBkZWZhdWx0VmFsdWUgPSAwKSB7XG4gIHJldHVybiBOdW1iZXIoc3RyKSB8fCBkZWZhdWx0VmFsdWU7XG59XG5cbi8vIFRha2VuIGZyb20gSFRNTCBzcGVjOiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbnB1dC5odG1sI3ZhbGlkLWUtbWFpbC1hZGRyZXNzXG5sZXQgckVtYWlsID1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuL15bYS16QS1aMC05LiEjJCUmJyorXFwvPT9eX2B7fH1+LV0rQFthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykqJC87XG5sZXQgclVybCA9XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbi9eKChodHRwcz98ZnRwKTopP1xcL1xcLygoKChbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoJVtcXGRhLWZdezJ9KXxbIVxcJCYnXFwoXFwpXFwqXFwrLDs9XXw6KSpAKT8oKChcXGR8WzEtOV1cXGR8MVxcZFxcZHwyWzAtNF1cXGR8MjVbMC01XSlcXC4oXFxkfFsxLTldXFxkfDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNV0pXFwuKFxcZHxbMS05XVxcZHwxXFxkXFxkfDJbMC00XVxcZHwyNVswLTVdKVxcLihcXGR8WzEtOV1cXGR8MVxcZFxcZHwyWzAtNF1cXGR8MjVbMC01XSkpfCgoKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSlcXC4pKygoW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCgoW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKVxcLj8pKDpcXGQqKT8pKFxcLygoKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCglW1xcZGEtZl17Mn0pfFshXFwkJidcXChcXClcXCpcXCssOz1dfDp8QCkrKFxcLygoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KCVbXFxkYS1mXXsyfSl8WyFcXCQmJ1xcKFxcKVxcKlxcKyw7PV18OnxAKSopKik/KT8oXFw/KCgoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KCVbXFxkYS1mXXsyfSl8WyFcXCQmJ1xcKFxcKVxcKlxcKyw7PV18OnxAKXxbXFx1RTAwMC1cXHVGOEZGXXxcXC98XFw/KSopPyhcXCMoKChbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoJVtcXGRhLWZdezJ9KXxbIVxcJCYnXFwoXFwpXFwqXFwrLDs9XXw6fEApfFxcL3xcXD8pKik/JC9pO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbmxldCByVVVJRCA9IC9eKD86WzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzEtNV1bMC05YS1mXXszfS1bODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwKSQvaTtcbmxldCB5ZWFyTW9udGhEYXkgPSAnXlxcXFxkezR9LVxcXFxkezJ9LVxcXFxkezJ9JztcbmxldCBob3VyTWludXRlU2Vjb25kID0gJ1xcXFxkezJ9OlxcXFxkezJ9OlxcXFxkezJ9JztcbmxldCB6T3JPZmZzZXQgPSAnKChbKy1dXFxcXGR7Mn0oOj9cXFxcZHsyfSk/KXxaKSc7XG5sZXQgcklzb0RhdGVUaW1lID0gbmV3IFJlZ0V4cChgJHt5ZWFyTW9udGhEYXl9VCR7aG91ck1pbnV0ZVNlY29uZH0oXFxcXC5cXFxcZCspPyR7ek9yT2Zmc2V0fSRgKTtcbmxldCBpc1RyaW1tZWQgPSB2YWx1ZSA9PiBpc0Fic2VudCh2YWx1ZSkgfHwgdmFsdWUgPT09IHZhbHVlLnRyaW0oKTtcbmxldCBvYmpTdHJpbmdUYWcgPSB7fS50b1N0cmluZygpO1xuZnVuY3Rpb24gY3JlYXRlJDYoKSB7XG4gIHJldHVybiBuZXcgU3RyaW5nU2NoZW1hKCk7XG59XG5jbGFzcyBTdHJpbmdTY2hlbWEgZXh0ZW5kcyBTY2hlbWEge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGNoZWNrKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZykgdmFsdWUgPSB2YWx1ZS52YWx1ZU9mKCk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMud2l0aE11dGF0aW9uKCgpID0+IHtcbiAgICAgIHRoaXMudHJhbnNmb3JtKCh2YWx1ZSwgX3JhdywgY3R4KSA9PiB7XG4gICAgICAgIGlmICghY3R4LnNwZWMuY29lcmNlIHx8IGN0eC5pc1R5cGUodmFsdWUpKSByZXR1cm4gdmFsdWU7XG5cbiAgICAgICAgLy8gZG9uJ3QgZXZlciBjb252ZXJ0IGFycmF5c1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgY29uc3Qgc3RyVmFsdWUgPSB2YWx1ZSAhPSBudWxsICYmIHZhbHVlLnRvU3RyaW5nID8gdmFsdWUudG9TdHJpbmcoKSA6IHZhbHVlO1xuXG4gICAgICAgIC8vIG5vIG9uZSB3YW50cyBwbGFpbiBvYmplY3RzIGNvbnZlcnRlZCB0byBbT2JqZWN0IG9iamVjdF1cbiAgICAgICAgaWYgKHN0clZhbHVlID09PSBvYmpTdHJpbmdUYWcpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHN0clZhbHVlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmVxdWlyZWQobWVzc2FnZSkge1xuICAgIHJldHVybiBzdXBlci5yZXF1aXJlZChtZXNzYWdlKS53aXRoTXV0YXRpb24oc2NoZW1hID0+IHNjaGVtYS50ZXN0KHtcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UgfHwgbWl4ZWQucmVxdWlyZWQsXG4gICAgICBuYW1lOiAncmVxdWlyZWQnLFxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcbiAgICAgIHRlc3Q6IHZhbHVlID0+ICEhdmFsdWUubGVuZ3RoXG4gICAgfSkpO1xuICB9XG4gIG5vdFJlcXVpcmVkKCkge1xuICAgIHJldHVybiBzdXBlci5ub3RSZXF1aXJlZCgpLndpdGhNdXRhdGlvbihzY2hlbWEgPT4ge1xuICAgICAgc2NoZW1hLnRlc3RzID0gc2NoZW1hLnRlc3RzLmZpbHRlcih0ID0+IHQuT1BUSU9OUy5uYW1lICE9PSAncmVxdWlyZWQnKTtcbiAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfSk7XG4gIH1cbiAgbGVuZ3RoKGxlbmd0aCwgbWVzc2FnZSA9IHN0cmluZy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAnbGVuZ3RoJyxcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBsZW5ndGhcbiAgICAgIH0sXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoID09PSB0aGlzLnJlc29sdmUobGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBtaW4obWluLCBtZXNzYWdlID0gc3RyaW5nLm1pbikge1xuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdtaW4nLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIG1pblxuICAgICAgfSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPj0gdGhpcy5yZXNvbHZlKG1pbik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbWF4KG1heCwgbWVzc2FnZSA9IHN0cmluZy5tYXgpIHtcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcbiAgICAgIG5hbWU6ICdtYXgnLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBtYXhcbiAgICAgIH0sXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoIDw9IHRoaXMucmVzb2x2ZShtYXgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG1hdGNoZXMocmVnZXgsIG9wdGlvbnMpIHtcbiAgICBsZXQgZXhjbHVkZUVtcHR5U3RyaW5nID0gZmFsc2U7XG4gICAgbGV0IG1lc3NhZ2U7XG4gICAgbGV0IG5hbWU7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgKHtcbiAgICAgICAgICBleGNsdWRlRW1wdHlTdHJpbmcgPSBmYWxzZSxcbiAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgIG5hbWVcbiAgICAgICAgfSA9IG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVzc2FnZSA9IG9wdGlvbnM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbmFtZTogbmFtZSB8fCAnbWF0Y2hlcycsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlIHx8IHN0cmluZy5tYXRjaGVzLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHJlZ2V4XG4gICAgICB9LFxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcbiAgICAgIHRlc3Q6IHZhbHVlID0+IHZhbHVlID09PSAnJyAmJiBleGNsdWRlRW1wdHlTdHJpbmcgfHwgdmFsdWUuc2VhcmNoKHJlZ2V4KSAhPT0gLTFcbiAgICB9KTtcbiAgfVxuICBlbWFpbChtZXNzYWdlID0gc3RyaW5nLmVtYWlsKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2hlcyhyRW1haWwsIHtcbiAgICAgIG5hbWU6ICdlbWFpbCcsXG4gICAgICBtZXNzYWdlLFxuICAgICAgZXhjbHVkZUVtcHR5U3RyaW5nOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgdXJsKG1lc3NhZ2UgPSBzdHJpbmcudXJsKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2hlcyhyVXJsLCB7XG4gICAgICBuYW1lOiAndXJsJyxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBleGNsdWRlRW1wdHlTdHJpbmc6IHRydWVcbiAgICB9KTtcbiAgfVxuICB1dWlkKG1lc3NhZ2UgPSBzdHJpbmcudXVpZCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoZXMoclVVSUQsIHtcbiAgICAgIG5hbWU6ICd1dWlkJyxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBleGNsdWRlRW1wdHlTdHJpbmc6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgZGF0ZXRpbWUob3B0aW9ucykge1xuICAgIGxldCBtZXNzYWdlID0gJyc7XG4gICAgbGV0IGFsbG93T2Zmc2V0O1xuICAgIGxldCBwcmVjaXNpb247XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgKHtcbiAgICAgICAgICBtZXNzYWdlID0gJycsXG4gICAgICAgICAgYWxsb3dPZmZzZXQgPSBmYWxzZSxcbiAgICAgICAgICBwcmVjaXNpb24gPSB1bmRlZmluZWRcbiAgICAgICAgfSA9IG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVzc2FnZSA9IG9wdGlvbnM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1hdGNoZXMocklzb0RhdGVUaW1lLCB7XG4gICAgICBuYW1lOiAnZGF0ZXRpbWUnLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSB8fCBzdHJpbmcuZGF0ZXRpbWUsXG4gICAgICBleGNsdWRlRW1wdHlTdHJpbmc6IHRydWVcbiAgICB9KS50ZXN0KHtcbiAgICAgIG5hbWU6ICdkYXRldGltZV9vZmZzZXQnLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSB8fCBzdHJpbmcuZGF0ZXRpbWVfb2Zmc2V0LFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIGFsbG93T2Zmc2V0XG4gICAgICB9LFxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcbiAgICAgIHRlc3Q6IHZhbHVlID0+IHtcbiAgICAgICAgaWYgKCF2YWx1ZSB8fCBhbGxvd09mZnNldCkgcmV0dXJuIHRydWU7XG4gICAgICAgIGNvbnN0IHN0cnVjdCA9IHBhcnNlRGF0ZVN0cnVjdCh2YWx1ZSk7XG4gICAgICAgIGlmICghc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiAhIXN0cnVjdC56O1xuICAgICAgfVxuICAgIH0pLnRlc3Qoe1xuICAgICAgbmFtZTogJ2RhdGV0aW1lX3ByZWNpc2lvbicsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlIHx8IHN0cmluZy5kYXRldGltZV9wcmVjaXNpb24sXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgcHJlY2lzaW9uXG4gICAgICB9LFxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcbiAgICAgIHRlc3Q6IHZhbHVlID0+IHtcbiAgICAgICAgaWYgKCF2YWx1ZSB8fCBwcmVjaXNpb24gPT0gdW5kZWZpbmVkKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY29uc3Qgc3RydWN0ID0gcGFyc2VEYXRlU3RydWN0KHZhbHVlKTtcbiAgICAgICAgaWYgKCFzdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHN0cnVjdC5wcmVjaXNpb24gPT09IHByZWNpc2lvbjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vLS0gdHJhbnNmb3JtcyAtLVxuICBlbnN1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmYXVsdCgnJykudHJhbnNmb3JtKHZhbCA9PiB2YWwgPT09IG51bGwgPyAnJyA6IHZhbCk7XG4gIH1cbiAgdHJpbShtZXNzYWdlID0gc3RyaW5nLnRyaW0pIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0odmFsID0+IHZhbCAhPSBudWxsID8gdmFsLnRyaW0oKSA6IHZhbCkudGVzdCh7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ3RyaW0nLFxuICAgICAgdGVzdDogaXNUcmltbWVkXG4gICAgfSk7XG4gIH1cbiAgbG93ZXJjYXNlKG1lc3NhZ2UgPSBzdHJpbmcubG93ZXJjYXNlKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHZhbHVlID0+ICFpc0Fic2VudCh2YWx1ZSkgPyB2YWx1ZS50b0xvd2VyQ2FzZSgpIDogdmFsdWUpLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdzdHJpbmdfY2FzZScsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdDogdmFsdWUgPT4gaXNBYnNlbnQodmFsdWUpIHx8IHZhbHVlID09PSB2YWx1ZS50b0xvd2VyQ2FzZSgpXG4gICAgfSk7XG4gIH1cbiAgdXBwZXJjYXNlKG1lc3NhZ2UgPSBzdHJpbmcudXBwZXJjYXNlKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHZhbHVlID0+ICFpc0Fic2VudCh2YWx1ZSkgPyB2YWx1ZS50b1VwcGVyQ2FzZSgpIDogdmFsdWUpLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdzdHJpbmdfY2FzZScsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdDogdmFsdWUgPT4gaXNBYnNlbnQodmFsdWUpIHx8IHZhbHVlID09PSB2YWx1ZS50b1VwcGVyQ2FzZSgpXG4gICAgfSk7XG4gIH1cbn1cbmNyZWF0ZSQ2LnByb3RvdHlwZSA9IFN0cmluZ1NjaGVtYS5wcm90b3R5cGU7XG5cbi8vXG4vLyBTdHJpbmcgSW50ZXJmYWNlc1xuLy9cblxubGV0IGlzTmFOJDEgPSB2YWx1ZSA9PiB2YWx1ZSAhPSArdmFsdWU7XG5mdW5jdGlvbiBjcmVhdGUkNSgpIHtcbiAgcmV0dXJuIG5ldyBOdW1iZXJTY2hlbWEoKTtcbn1cbmNsYXNzIE51bWJlclNjaGVtYSBleHRlbmRzIFNjaGVtYSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgY2hlY2sodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyKSB2YWx1ZSA9IHZhbHVlLnZhbHVlT2YoKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOJDEodmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMud2l0aE11dGF0aW9uKCgpID0+IHtcbiAgICAgIHRoaXMudHJhbnNmb3JtKCh2YWx1ZSwgX3JhdywgY3R4KSA9PiB7XG4gICAgICAgIGlmICghY3R4LnNwZWMuY29lcmNlKSByZXR1cm4gdmFsdWU7XG4gICAgICAgIGxldCBwYXJzZWQgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJzZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcGFyc2VkID0gcGFyc2VkLnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgICAgICAgaWYgKHBhcnNlZCA9PT0gJycpIHJldHVybiBOYU47XG4gICAgICAgICAgLy8gZG9uJ3QgdXNlIHBhcnNlRmxvYXQgdG8gYXZvaWQgcG9zaXRpdmVzIG9uIGFscGhhLW51bWVyaWMgc3RyaW5nc1xuICAgICAgICAgIHBhcnNlZCA9ICtwYXJzZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBudWxsIC0+IE5hTiBpc24ndCB1c2VmdWw7IHRyZWF0IGFsbCBudWxscyBhcyBudWxsIGFuZCBsZXQgaXQgZmFpbCBvblxuICAgICAgICAvLyBudWxsYWJpbGl0eSBjaGVjayB2cyBUeXBlRXJyb3JzXG4gICAgICAgIGlmIChjdHguaXNUeXBlKHBhcnNlZCkgfHwgcGFyc2VkID09PSBudWxsKSByZXR1cm4gcGFyc2VkO1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChwYXJzZWQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgbWluKG1pbiwgbWVzc2FnZSA9IG51bWJlci5taW4pIHtcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAnbWluJyxcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBtaW5cbiAgICAgIH0sXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPj0gdGhpcy5yZXNvbHZlKG1pbik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbWF4KG1heCwgbWVzc2FnZSA9IG51bWJlci5tYXgpIHtcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAnbWF4JyxcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBtYXhcbiAgICAgIH0sXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPD0gdGhpcy5yZXNvbHZlKG1heCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbGVzc1RoYW4obGVzcywgbWVzc2FnZSA9IG51bWJlci5sZXNzVGhhbikge1xuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdtYXgnLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIGxlc3NcbiAgICAgIH0sXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPCB0aGlzLnJlc29sdmUobGVzcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbW9yZVRoYW4obW9yZSwgbWVzc2FnZSA9IG51bWJlci5tb3JlVGhhbikge1xuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdtaW4nLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIG1vcmVcbiAgICAgIH0sXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPiB0aGlzLnJlc29sdmUobW9yZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcG9zaXRpdmUobXNnID0gbnVtYmVyLnBvc2l0aXZlKSB7XG4gICAgcmV0dXJuIHRoaXMubW9yZVRoYW4oMCwgbXNnKTtcbiAgfVxuICBuZWdhdGl2ZShtc2cgPSBudW1iZXIubmVnYXRpdmUpIHtcbiAgICByZXR1cm4gdGhpcy5sZXNzVGhhbigwLCBtc2cpO1xuICB9XG4gIGludGVnZXIobWVzc2FnZSA9IG51bWJlci5pbnRlZ2VyKSB7XG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XG4gICAgICBuYW1lOiAnaW50ZWdlcicsXG4gICAgICBtZXNzYWdlLFxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcbiAgICAgIHRlc3Q6IHZhbCA9PiBOdW1iZXIuaXNJbnRlZ2VyKHZhbClcbiAgICB9KTtcbiAgfVxuICB0cnVuY2F0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0odmFsdWUgPT4gIWlzQWJzZW50KHZhbHVlKSA/IHZhbHVlIHwgMCA6IHZhbHVlKTtcbiAgfVxuICByb3VuZChtZXRob2QpIHtcbiAgICB2YXIgX21ldGhvZDtcbiAgICBsZXQgYXZhaWwgPSBbJ2NlaWwnLCAnZmxvb3InLCAncm91bmQnLCAndHJ1bmMnXTtcbiAgICBtZXRob2QgPSAoKF9tZXRob2QgPSBtZXRob2QpID09IG51bGwgPyB2b2lkIDAgOiBfbWV0aG9kLnRvTG93ZXJDYXNlKCkpIHx8ICdyb3VuZCc7XG5cbiAgICAvLyB0aGlzIGV4aXN0cyBmb3Igc3ltZW10cnkgd2l0aCB0aGUgbmV3IE1hdGgudHJ1bmNcbiAgICBpZiAobWV0aG9kID09PSAndHJ1bmMnKSByZXR1cm4gdGhpcy50cnVuY2F0ZSgpO1xuICAgIGlmIChhdmFpbC5pbmRleE9mKG1ldGhvZC50b0xvd2VyQ2FzZSgpKSA9PT0gLTEpIHRocm93IG5ldyBUeXBlRXJyb3IoJ09ubHkgdmFsaWQgb3B0aW9ucyBmb3Igcm91bmQoKSBhcmU6ICcgKyBhdmFpbC5qb2luKCcsICcpKTtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0odmFsdWUgPT4gIWlzQWJzZW50KHZhbHVlKSA/IE1hdGhbbWV0aG9kXSh2YWx1ZSkgOiB2YWx1ZSk7XG4gIH1cbn1cbmNyZWF0ZSQ1LnByb3RvdHlwZSA9IE51bWJlclNjaGVtYS5wcm90b3R5cGU7XG5cbi8vXG4vLyBOdW1iZXIgSW50ZXJmYWNlc1xuLy9cblxubGV0IGludmFsaWREYXRlID0gbmV3IERhdGUoJycpO1xubGV0IGlzRGF0ZSA9IG9iaiA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xuZnVuY3Rpb24gY3JlYXRlJDQoKSB7XG4gIHJldHVybiBuZXcgRGF0ZVNjaGVtYSgpO1xufVxuY2xhc3MgRGF0ZVNjaGVtYSBleHRlbmRzIFNjaGVtYSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHtcbiAgICAgIHR5cGU6ICdkYXRlJyxcbiAgICAgIGNoZWNrKHYpIHtcbiAgICAgICAgcmV0dXJuIGlzRGF0ZSh2KSAmJiAhaXNOYU4odi5nZXRUaW1lKCkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMud2l0aE11dGF0aW9uKCgpID0+IHtcbiAgICAgIHRoaXMudHJhbnNmb3JtKCh2YWx1ZSwgX3JhdywgY3R4KSA9PiB7XG4gICAgICAgIC8vIG51bGwgLT4gSW52YWxpZERhdGUgaXNuJ3QgdXNlZnVsOyB0cmVhdCBhbGwgbnVsbHMgYXMgbnVsbCBhbmQgbGV0IGl0IGZhaWwgb25cbiAgICAgICAgLy8gbnVsbGFiaWxpdHkgY2hlY2sgdnMgVHlwZUVycm9yc1xuICAgICAgICBpZiAoIWN0eC5zcGVjLmNvZXJjZSB8fCBjdHguaXNUeXBlKHZhbHVlKSB8fCB2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9IHBhcnNlSXNvRGF0ZSh2YWx1ZSk7XG5cbiAgICAgICAgLy8gMCBpcyBhIHZhbGlkIHRpbWVzdGFtcCBlcXVpdmFsZW50IHRvIDE5NzAtMDEtMDFUMDA6MDA6MDBaKHVuaXggZXBvY2gpIG9yIGJlZm9yZS5cbiAgICAgICAgcmV0dXJuICFpc05hTih2YWx1ZSkgPyBuZXcgRGF0ZSh2YWx1ZSkgOiBEYXRlU2NoZW1hLklOVkFMSURfREFURTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHByZXBhcmVQYXJhbShyZWYsIG5hbWUpIHtcbiAgICBsZXQgcGFyYW07XG4gICAgaWYgKCFSZWZlcmVuY2UuaXNSZWYocmVmKSkge1xuICAgICAgbGV0IGNhc3QgPSB0aGlzLmNhc3QocmVmKTtcbiAgICAgIGlmICghdGhpcy5fdHlwZUNoZWNrKGNhc3QpKSB0aHJvdyBuZXcgVHlwZUVycm9yKGBcXGAke25hbWV9XFxgIG11c3QgYmUgYSBEYXRlIG9yIGEgdmFsdWUgdGhhdCBjYW4gYmUgXFxgY2FzdCgpXFxgIHRvIGEgRGF0ZWApO1xuICAgICAgcGFyYW0gPSBjYXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJhbSA9IHJlZjtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtO1xuICB9XG4gIG1pbihtaW4sIG1lc3NhZ2UgPSBkYXRlLm1pbikge1xuICAgIGxldCBsaW1pdCA9IHRoaXMucHJlcGFyZVBhcmFtKG1pbiwgJ21pbicpO1xuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdtaW4nLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIG1pblxuICAgICAgfSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA+PSB0aGlzLnJlc29sdmUobGltaXQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG1heChtYXgsIG1lc3NhZ2UgPSBkYXRlLm1heCkge1xuICAgIGxldCBsaW1pdCA9IHRoaXMucHJlcGFyZVBhcmFtKG1heCwgJ21heCcpO1xuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdtYXgnLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIG1heFxuICAgICAgfSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA8PSB0aGlzLnJlc29sdmUobGltaXQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5EYXRlU2NoZW1hLklOVkFMSURfREFURSA9IGludmFsaWREYXRlO1xuY3JlYXRlJDQucHJvdG90eXBlID0gRGF0ZVNjaGVtYS5wcm90b3R5cGU7XG5jcmVhdGUkNC5JTlZBTElEX0RBVEUgPSBpbnZhbGlkRGF0ZTtcblxuLy8gQHRzLWV4cGVjdC1lcnJvclxuZnVuY3Rpb24gc29ydEZpZWxkcyhmaWVsZHMsIGV4Y2x1ZGVkRWRnZXMgPSBbXSkge1xuICBsZXQgZWRnZXMgPSBbXTtcbiAgbGV0IG5vZGVzID0gbmV3IFNldCgpO1xuICBsZXQgZXhjbHVkZXMgPSBuZXcgU2V0KGV4Y2x1ZGVkRWRnZXMubWFwKChbYSwgYl0pID0+IGAke2F9LSR7Yn1gKSk7XG4gIGZ1bmN0aW9uIGFkZE5vZGUoZGVwUGF0aCwga2V5KSB7XG4gICAgbGV0IG5vZGUgPSBzcGxpdChkZXBQYXRoKVswXTtcbiAgICBub2Rlcy5hZGQobm9kZSk7XG4gICAgaWYgKCFleGNsdWRlcy5oYXMoYCR7a2V5fS0ke25vZGV9YCkpIGVkZ2VzLnB1c2goW2tleSwgbm9kZV0pO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGZpZWxkcykpIHtcbiAgICBsZXQgdmFsdWUgPSBmaWVsZHNba2V5XTtcbiAgICBub2Rlcy5hZGQoa2V5KTtcbiAgICBpZiAoUmVmZXJlbmNlLmlzUmVmKHZhbHVlKSAmJiB2YWx1ZS5pc1NpYmxpbmcpIGFkZE5vZGUodmFsdWUucGF0aCwga2V5KTtlbHNlIGlmIChpc1NjaGVtYSh2YWx1ZSkgJiYgJ2RlcHMnIGluIHZhbHVlKSB2YWx1ZS5kZXBzLmZvckVhY2gocGF0aCA9PiBhZGROb2RlKHBhdGgsIGtleSkpO1xuICB9XG4gIHJldHVybiB0b3Bvc29ydC5hcnJheShBcnJheS5mcm9tKG5vZGVzKSwgZWRnZXMpLnJldmVyc2UoKTtcbn1cblxuZnVuY3Rpb24gZmluZEluZGV4KGFyciwgZXJyKSB7XG4gIGxldCBpZHggPSBJbmZpbml0eTtcbiAgYXJyLnNvbWUoKGtleSwgaWkpID0+IHtcbiAgICB2YXIgX2VyciRwYXRoO1xuICAgIGlmICgoX2VyciRwYXRoID0gZXJyLnBhdGgpICE9IG51bGwgJiYgX2VyciRwYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIGlkeCA9IGlpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGlkeDtcbn1cbmZ1bmN0aW9uIHNvcnRCeUtleU9yZGVyKGtleXMpIHtcbiAgcmV0dXJuIChhLCBiKSA9PiB7XG4gICAgcmV0dXJuIGZpbmRJbmRleChrZXlzLCBhKSAtIGZpbmRJbmRleChrZXlzLCBiKTtcbiAgfTtcbn1cblxuY29uc3QgcGFyc2VKc29uID0gKHZhbHVlLCBfLCBjdHgpID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgbGV0IHBhcnNlZCA9IHZhbHVlO1xuICB0cnkge1xuICAgIHBhcnNlZCA9IEpTT04ucGFyc2UodmFsdWUpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvKiAqL1xuICB9XG4gIHJldHVybiBjdHguaXNUeXBlKHBhcnNlZCkgPyBwYXJzZWQgOiB2YWx1ZTtcbn07XG5cbi8vIEB0cy1pZ25vcmVcbmZ1bmN0aW9uIGRlZXBQYXJ0aWFsKHNjaGVtYSkge1xuICBpZiAoJ2ZpZWxkcycgaW4gc2NoZW1hKSB7XG4gICAgY29uc3QgcGFydGlhbCA9IHt9O1xuICAgIGZvciAoY29uc3QgW2tleSwgZmllbGRTY2hlbWFdIG9mIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5maWVsZHMpKSB7XG4gICAgICBwYXJ0aWFsW2tleV0gPSBkZWVwUGFydGlhbChmaWVsZFNjaGVtYSk7XG4gICAgfVxuICAgIHJldHVybiBzY2hlbWEuc2V0RmllbGRzKHBhcnRpYWwpO1xuICB9XG4gIGlmIChzY2hlbWEudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgIGNvbnN0IG5leHRBcnJheSA9IHNjaGVtYS5vcHRpb25hbCgpO1xuICAgIGlmIChuZXh0QXJyYXkuaW5uZXJUeXBlKSBuZXh0QXJyYXkuaW5uZXJUeXBlID0gZGVlcFBhcnRpYWwobmV4dEFycmF5LmlubmVyVHlwZSk7XG4gICAgcmV0dXJuIG5leHRBcnJheTtcbiAgfVxuICBpZiAoc2NoZW1hLnR5cGUgPT09ICd0dXBsZScpIHtcbiAgICByZXR1cm4gc2NoZW1hLm9wdGlvbmFsKCkuY2xvbmUoe1xuICAgICAgdHlwZXM6IHNjaGVtYS5zcGVjLnR5cGVzLm1hcChkZWVwUGFydGlhbClcbiAgICB9KTtcbiAgfVxuICBpZiAoJ29wdGlvbmFsJyBpbiBzY2hlbWEpIHtcbiAgICByZXR1cm4gc2NoZW1hLm9wdGlvbmFsKCk7XG4gIH1cbiAgcmV0dXJuIHNjaGVtYTtcbn1cbmNvbnN0IGRlZXBIYXMgPSAob2JqLCBwKSA9PiB7XG4gIGNvbnN0IHBhdGggPSBbLi4ubm9ybWFsaXplUGF0aChwKV07XG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHBhdGhbMF0gaW4gb2JqO1xuICBsZXQgbGFzdCA9IHBhdGgucG9wKCk7XG4gIGxldCBwYXJlbnQgPSBnZXR0ZXIoam9pbihwYXRoKSwgdHJ1ZSkob2JqKTtcbiAgcmV0dXJuICEhKHBhcmVudCAmJiBsYXN0IGluIHBhcmVudCk7XG59O1xubGV0IGlzT2JqZWN0ID0gb2JqID0+IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJztcbmZ1bmN0aW9uIHVua25vd24oY3R4LCB2YWx1ZSkge1xuICBsZXQga25vd24gPSBPYmplY3Qua2V5cyhjdHguZmllbGRzKTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKS5maWx0ZXIoa2V5ID0+IGtub3duLmluZGV4T2Yoa2V5KSA9PT0gLTEpO1xufVxuY29uc3QgZGVmYXVsdFNvcnQgPSBzb3J0QnlLZXlPcmRlcihbXSk7XG5mdW5jdGlvbiBjcmVhdGUkMyhzcGVjKSB7XG4gIHJldHVybiBuZXcgT2JqZWN0U2NoZW1hKHNwZWMpO1xufVxuY2xhc3MgT2JqZWN0U2NoZW1hIGV4dGVuZHMgU2NoZW1hIHtcbiAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgIHN1cGVyKHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgY2hlY2sodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5maWVsZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX3NvcnRFcnJvcnMgPSBkZWZhdWx0U29ydDtcbiAgICB0aGlzLl9ub2RlcyA9IFtdO1xuICAgIHRoaXMuX2V4Y2x1ZGVkRWRnZXMgPSBbXTtcbiAgICB0aGlzLndpdGhNdXRhdGlvbigoKSA9PiB7XG4gICAgICBpZiAoc3BlYykge1xuICAgICAgICB0aGlzLnNoYXBlKHNwZWMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF9jYXN0KF92YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdmFyIF9vcHRpb25zJHN0cmlwVW5rbm93bjtcbiAgICBsZXQgdmFsdWUgPSBzdXBlci5fY2FzdChfdmFsdWUsIG9wdGlvbnMpO1xuXG4gICAgLy9zaG91bGQgaWdub3JlIG51bGxzIGhlcmVcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXMuZ2V0RGVmYXVsdChvcHRpb25zKTtcbiAgICBpZiAoIXRoaXMuX3R5cGVDaGVjayh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICBsZXQgZmllbGRzID0gdGhpcy5maWVsZHM7XG4gICAgbGV0IHN0cmlwID0gKF9vcHRpb25zJHN0cmlwVW5rbm93biA9IG9wdGlvbnMuc3RyaXBVbmtub3duKSAhPSBudWxsID8gX29wdGlvbnMkc3RyaXBVbmtub3duIDogdGhpcy5zcGVjLm5vVW5rbm93bjtcbiAgICBsZXQgcHJvcHMgPSBbXS5jb25jYXQodGhpcy5fbm9kZXMsIE9iamVjdC5rZXlzKHZhbHVlKS5maWx0ZXIodiA9PiAhdGhpcy5fbm9kZXMuaW5jbHVkZXModikpKTtcbiAgICBsZXQgaW50ZXJtZWRpYXRlVmFsdWUgPSB7fTsgLy8gaXMgZmlsbGVkIGR1cmluZyB0aGUgdHJhbnNmb3JtIGJlbG93XG4gICAgbGV0IGlubmVyT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgIHBhcmVudDogaW50ZXJtZWRpYXRlVmFsdWUsXG4gICAgICBfX3ZhbGlkYXRpbmc6IG9wdGlvbnMuX192YWxpZGF0aW5nIHx8IGZhbHNlXG4gICAgfSk7XG4gICAgbGV0IGlzQ2hhbmdlZCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgcHJvcCBvZiBwcm9wcykge1xuICAgICAgbGV0IGZpZWxkID0gZmllbGRzW3Byb3BdO1xuICAgICAgbGV0IGV4aXN0cyA9IChwcm9wIGluIHZhbHVlKTtcbiAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICBsZXQgZmllbGRWYWx1ZTtcbiAgICAgICAgbGV0IGlucHV0VmFsdWUgPSB2YWx1ZVtwcm9wXTtcblxuICAgICAgICAvLyBzYWZlIHRvIG11dGF0ZSBzaW5jZSB0aGlzIGlzIGZpcmVkIGluIHNlcXVlbmNlXG4gICAgICAgIGlubmVyT3B0aW9ucy5wYXRoID0gKG9wdGlvbnMucGF0aCA/IGAke29wdGlvbnMucGF0aH0uYCA6ICcnKSArIHByb3A7XG4gICAgICAgIGZpZWxkID0gZmllbGQucmVzb2x2ZSh7XG4gICAgICAgICAgdmFsdWU6IGlucHV0VmFsdWUsXG4gICAgICAgICAgY29udGV4dDogb3B0aW9ucy5jb250ZXh0LFxuICAgICAgICAgIHBhcmVudDogaW50ZXJtZWRpYXRlVmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBmaWVsZFNwZWMgPSBmaWVsZCBpbnN0YW5jZW9mIFNjaGVtYSA/IGZpZWxkLnNwZWMgOiB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBzdHJpY3QgPSBmaWVsZFNwZWMgPT0gbnVsbCA/IHZvaWQgMCA6IGZpZWxkU3BlYy5zdHJpY3Q7XG4gICAgICAgIGlmIChmaWVsZFNwZWMgIT0gbnVsbCAmJiBmaWVsZFNwZWMuc3RyaXApIHtcbiAgICAgICAgICBpc0NoYW5nZWQgPSBpc0NoYW5nZWQgfHwgcHJvcCBpbiB2YWx1ZTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmaWVsZFZhbHVlID0gIW9wdGlvbnMuX192YWxpZGF0aW5nIHx8ICFzdHJpY3QgP1xuICAgICAgICAvLyBUT0RPOiB1c2UgX2Nhc3QsIHRoaXMgaXMgZG91YmxlIHJlc29sdmluZ1xuICAgICAgICBmaWVsZC5jYXN0KHZhbHVlW3Byb3BdLCBpbm5lck9wdGlvbnMpIDogdmFsdWVbcHJvcF07XG4gICAgICAgIGlmIChmaWVsZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpbnRlcm1lZGlhdGVWYWx1ZVtwcm9wXSA9IGZpZWxkVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZXhpc3RzICYmICFzdHJpcCkge1xuICAgICAgICBpbnRlcm1lZGlhdGVWYWx1ZVtwcm9wXSA9IHZhbHVlW3Byb3BdO1xuICAgICAgfVxuICAgICAgaWYgKGV4aXN0cyAhPT0gcHJvcCBpbiBpbnRlcm1lZGlhdGVWYWx1ZSB8fCBpbnRlcm1lZGlhdGVWYWx1ZVtwcm9wXSAhPT0gdmFsdWVbcHJvcF0pIHtcbiAgICAgICAgaXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlzQ2hhbmdlZCA/IGludGVybWVkaWF0ZVZhbHVlIDogdmFsdWU7XG4gIH1cbiAgX3ZhbGlkYXRlKF92YWx1ZSwgb3B0aW9ucyA9IHt9LCBwYW5pYywgbmV4dCkge1xuICAgIGxldCB7XG4gICAgICBmcm9tID0gW10sXG4gICAgICBvcmlnaW5hbFZhbHVlID0gX3ZhbHVlLFxuICAgICAgcmVjdXJzaXZlID0gdGhpcy5zcGVjLnJlY3Vyc2l2ZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIG9wdGlvbnMuZnJvbSA9IFt7XG4gICAgICBzY2hlbWE6IHRoaXMsXG4gICAgICB2YWx1ZTogb3JpZ2luYWxWYWx1ZVxuICAgIH0sIC4uLmZyb21dO1xuICAgIC8vIHRoaXMgZmxhZyBpcyBuZWVkZWQgZm9yIGhhbmRsaW5nIGBzdHJpY3RgIGNvcnJlY3RseSBpbiB0aGUgY29udGV4dCBvZlxuICAgIC8vIHZhbGlkYXRpb24gdnMganVzdCBjYXN0aW5nLiBlLmcgc3RyaWN0KCkgb24gYSBmaWVsZCBpcyBvbmx5IHVzZWQgd2hlbiB2YWxpZGF0aW5nXG4gICAgb3B0aW9ucy5fX3ZhbGlkYXRpbmcgPSB0cnVlO1xuICAgIG9wdGlvbnMub3JpZ2luYWxWYWx1ZSA9IG9yaWdpbmFsVmFsdWU7XG4gICAgc3VwZXIuX3ZhbGlkYXRlKF92YWx1ZSwgb3B0aW9ucywgcGFuaWMsIChvYmplY3RFcnJvcnMsIHZhbHVlKSA9PiB7XG4gICAgICBpZiAoIXJlY3Vyc2l2ZSB8fCAhaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIG5leHQob2JqZWN0RXJyb3JzLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG9yaWdpbmFsVmFsdWUgPSBvcmlnaW5hbFZhbHVlIHx8IHZhbHVlO1xuICAgICAgbGV0IHRlc3RzID0gW107XG4gICAgICBmb3IgKGxldCBrZXkgb2YgdGhpcy5fbm9kZXMpIHtcbiAgICAgICAgbGV0IGZpZWxkID0gdGhpcy5maWVsZHNba2V5XTtcbiAgICAgICAgaWYgKCFmaWVsZCB8fCBSZWZlcmVuY2UuaXNSZWYoZmllbGQpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGVzdHMucHVzaChmaWVsZC5hc05lc3RlZFRlc3Qoe1xuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIHBhcmVudDogdmFsdWUsXG4gICAgICAgICAgcGFyZW50UGF0aDogb3B0aW9ucy5wYXRoLFxuICAgICAgICAgIG9yaWdpbmFsUGFyZW50OiBvcmlnaW5hbFZhbHVlXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucnVuVGVzdHMoe1xuICAgICAgICB0ZXN0cyxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIG9yaWdpbmFsVmFsdWUsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH0sIHBhbmljLCBmaWVsZEVycm9ycyA9PiB7XG4gICAgICAgIG5leHQoZmllbGRFcnJvcnMuc29ydCh0aGlzLl9zb3J0RXJyb3JzKS5jb25jYXQob2JqZWN0RXJyb3JzKSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgY2xvbmUoc3BlYykge1xuICAgIGNvbnN0IG5leHQgPSBzdXBlci5jbG9uZShzcGVjKTtcbiAgICBuZXh0LmZpZWxkcyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZmllbGRzKTtcbiAgICBuZXh0Ll9ub2RlcyA9IHRoaXMuX25vZGVzO1xuICAgIG5leHQuX2V4Y2x1ZGVkRWRnZXMgPSB0aGlzLl9leGNsdWRlZEVkZ2VzO1xuICAgIG5leHQuX3NvcnRFcnJvcnMgPSB0aGlzLl9zb3J0RXJyb3JzO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIGNvbmNhdChzY2hlbWEpIHtcbiAgICBsZXQgbmV4dCA9IHN1cGVyLmNvbmNhdChzY2hlbWEpO1xuICAgIGxldCBuZXh0RmllbGRzID0gbmV4dC5maWVsZHM7XG4gICAgZm9yIChsZXQgW2ZpZWxkLCBzY2hlbWFPclJlZl0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5maWVsZHMpKSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBuZXh0RmllbGRzW2ZpZWxkXTtcbiAgICAgIG5leHRGaWVsZHNbZmllbGRdID0gdGFyZ2V0ID09PSB1bmRlZmluZWQgPyBzY2hlbWFPclJlZiA6IHRhcmdldDtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQud2l0aE11dGF0aW9uKHMgPT5cbiAgICAvLyBYWFg6IGV4Y2x1ZGVzIGhlcmUgaXMgd3JvbmdcbiAgICBzLnNldEZpZWxkcyhuZXh0RmllbGRzLCBbLi4udGhpcy5fZXhjbHVkZWRFZGdlcywgLi4uc2NoZW1hLl9leGNsdWRlZEVkZ2VzXSkpO1xuICB9XG4gIF9nZXREZWZhdWx0KG9wdGlvbnMpIHtcbiAgICBpZiAoJ2RlZmF1bHQnIGluIHRoaXMuc3BlYykge1xuICAgICAgcmV0dXJuIHN1cGVyLl9nZXREZWZhdWx0KG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8vIGlmIHRoZXJlIGlzIG5vIGRlZmF1bHQgc2V0IGludmVudCBvbmVcbiAgICBpZiAoIXRoaXMuX25vZGVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbGV0IGRmdCA9IHt9O1xuICAgIHRoaXMuX25vZGVzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIHZhciBfaW5uZXJPcHRpb25zO1xuICAgICAgY29uc3QgZmllbGQgPSB0aGlzLmZpZWxkc1trZXldO1xuICAgICAgbGV0IGlubmVyT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICBpZiAoKF9pbm5lck9wdGlvbnMgPSBpbm5lck9wdGlvbnMpICE9IG51bGwgJiYgX2lubmVyT3B0aW9ucy52YWx1ZSkge1xuICAgICAgICBpbm5lck9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBpbm5lck9wdGlvbnMsIHtcbiAgICAgICAgICBwYXJlbnQ6IGlubmVyT3B0aW9ucy52YWx1ZSxcbiAgICAgICAgICB2YWx1ZTogaW5uZXJPcHRpb25zLnZhbHVlW2tleV1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkZnRba2V5XSA9IGZpZWxkICYmICdnZXREZWZhdWx0JyBpbiBmaWVsZCA/IGZpZWxkLmdldERlZmF1bHQoaW5uZXJPcHRpb25zKSA6IHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgICByZXR1cm4gZGZ0O1xuICB9XG4gIHNldEZpZWxkcyhzaGFwZSwgZXhjbHVkZWRFZGdlcykge1xuICAgIGxldCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xuICAgIG5leHQuZmllbGRzID0gc2hhcGU7XG4gICAgbmV4dC5fbm9kZXMgPSBzb3J0RmllbGRzKHNoYXBlLCBleGNsdWRlZEVkZ2VzKTtcbiAgICBuZXh0Ll9zb3J0RXJyb3JzID0gc29ydEJ5S2V5T3JkZXIoT2JqZWN0LmtleXMoc2hhcGUpKTtcbiAgICAvLyBYWFg6IHRoaXMgY2FycmllcyBvdmVyIGVkZ2VzIHdoaWNoIG1heSBub3QgYmUgd2hhdCB5b3Ugd2FudFxuICAgIGlmIChleGNsdWRlZEVkZ2VzKSBuZXh0Ll9leGNsdWRlZEVkZ2VzID0gZXhjbHVkZWRFZGdlcztcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICBzaGFwZShhZGRpdGlvbnMsIGV4Y2x1ZGVzID0gW10pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLndpdGhNdXRhdGlvbihuZXh0ID0+IHtcbiAgICAgIGxldCBlZGdlcyA9IG5leHQuX2V4Y2x1ZGVkRWRnZXM7XG4gICAgICBpZiAoZXhjbHVkZXMubGVuZ3RoKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShleGNsdWRlc1swXSkpIGV4Y2x1ZGVzID0gW2V4Y2x1ZGVzXTtcbiAgICAgICAgZWRnZXMgPSBbLi4ubmV4dC5fZXhjbHVkZWRFZGdlcywgLi4uZXhjbHVkZXNdO1xuICAgICAgfVxuXG4gICAgICAvLyBYWFg6IGV4Y2x1ZGVzIGhlcmUgaXMgd3JvbmdcbiAgICAgIHJldHVybiBuZXh0LnNldEZpZWxkcyhPYmplY3QuYXNzaWduKG5leHQuZmllbGRzLCBhZGRpdGlvbnMpLCBlZGdlcyk7XG4gICAgfSk7XG4gIH1cbiAgcGFydGlhbCgpIHtcbiAgICBjb25zdCBwYXJ0aWFsID0ge307XG4gICAgZm9yIChjb25zdCBba2V5LCBzY2hlbWFdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuZmllbGRzKSkge1xuICAgICAgcGFydGlhbFtrZXldID0gJ29wdGlvbmFsJyBpbiBzY2hlbWEgJiYgc2NoZW1hLm9wdGlvbmFsIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBzY2hlbWEub3B0aW9uYWwoKSA6IHNjaGVtYTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2V0RmllbGRzKHBhcnRpYWwpO1xuICB9XG4gIGRlZXBQYXJ0aWFsKCkge1xuICAgIGNvbnN0IG5leHQgPSBkZWVwUGFydGlhbCh0aGlzKTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICBwaWNrKGtleXMpIHtcbiAgICBjb25zdCBwaWNrZWQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICBpZiAodGhpcy5maWVsZHNba2V5XSkgcGlja2VkW2tleV0gPSB0aGlzLmZpZWxkc1trZXldO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zZXRGaWVsZHMocGlja2VkLCB0aGlzLl9leGNsdWRlZEVkZ2VzLmZpbHRlcigoW2EsIGJdKSA9PiBrZXlzLmluY2x1ZGVzKGEpICYmIGtleXMuaW5jbHVkZXMoYikpKTtcbiAgfVxuICBvbWl0KGtleXMpIHtcbiAgICBjb25zdCByZW1haW5pbmcgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzLmZpZWxkcykpIHtcbiAgICAgIGlmIChrZXlzLmluY2x1ZGVzKGtleSkpIGNvbnRpbnVlO1xuICAgICAgcmVtYWluaW5nLnB1c2goa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGljayhyZW1haW5pbmcpO1xuICB9XG4gIGZyb20oZnJvbSwgdG8sIGFsaWFzKSB7XG4gICAgbGV0IGZyb21HZXR0ZXIgPSBnZXR0ZXIoZnJvbSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKG9iaiA9PiB7XG4gICAgICBpZiAoIW9iaikgcmV0dXJuIG9iajtcbiAgICAgIGxldCBuZXdPYmogPSBvYmo7XG4gICAgICBpZiAoZGVlcEhhcyhvYmosIGZyb20pKSB7XG4gICAgICAgIG5ld09iaiA9IE9iamVjdC5hc3NpZ24oe30sIG9iaik7XG4gICAgICAgIGlmICghYWxpYXMpIGRlbGV0ZSBuZXdPYmpbZnJvbV07XG4gICAgICAgIG5ld09ialt0b10gPSBmcm9tR2V0dGVyKG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3T2JqO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIFBhcnNlIGFuIGlucHV0IEpTT04gc3RyaW5nIHRvIGFuIG9iamVjdCAqL1xuICBqc29uKCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybShwYXJzZUpzb24pO1xuICB9XG4gIG5vVW5rbm93bihub0FsbG93ID0gdHJ1ZSwgbWVzc2FnZSA9IG9iamVjdC5ub1Vua25vd24pIHtcbiAgICBpZiAodHlwZW9mIG5vQWxsb3cgIT09ICdib29sZWFuJykge1xuICAgICAgbWVzc2FnZSA9IG5vQWxsb3c7XG4gICAgICBub0FsbG93ID0gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IG5leHQgPSB0aGlzLnRlc3Qoe1xuICAgICAgbmFtZTogJ25vVW5rbm93bicsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gICAgICAgIGNvbnN0IHVua25vd25LZXlzID0gdW5rbm93bih0aGlzLnNjaGVtYSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gIW5vQWxsb3cgfHwgdW5rbm93bktleXMubGVuZ3RoID09PSAwIHx8IHRoaXMuY3JlYXRlRXJyb3Ioe1xuICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgdW5rbm93bjogdW5rbm93bktleXMuam9pbignLCAnKVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbmV4dC5zcGVjLm5vVW5rbm93biA9IG5vQWxsb3c7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgdW5rbm93bihhbGxvdyA9IHRydWUsIG1lc3NhZ2UgPSBvYmplY3Qubm9Vbmtub3duKSB7XG4gICAgcmV0dXJuIHRoaXMubm9Vbmtub3duKCFhbGxvdywgbWVzc2FnZSk7XG4gIH1cbiAgdHJhbnNmb3JtS2V5cyhmbikge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybShvYmogPT4ge1xuICAgICAgaWYgKCFvYmopIHJldHVybiBvYmo7XG4gICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpIHJlc3VsdFtmbihrZXkpXSA9IG9ialtrZXldO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcbiAgfVxuICBjYW1lbENhc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtS2V5cyhjYW1lbENhc2UpO1xuICB9XG4gIHNuYWtlQ2FzZSgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1LZXlzKHNuYWtlQ2FzZSk7XG4gIH1cbiAgY29uc3RhbnRDYXNlKCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUtleXMoa2V5ID0+IHNuYWtlQ2FzZShrZXkpLnRvVXBwZXJDYXNlKCkpO1xuICB9XG4gIGRlc2NyaWJlKG9wdGlvbnMpIHtcbiAgICBjb25zdCBuZXh0ID0gKG9wdGlvbnMgPyB0aGlzLnJlc29sdmUob3B0aW9ucykgOiB0aGlzKS5jbG9uZSgpO1xuICAgIGNvbnN0IGJhc2UgPSBzdXBlci5kZXNjcmliZShvcHRpb25zKTtcbiAgICBiYXNlLmZpZWxkcyA9IHt9O1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG5leHQuZmllbGRzKSkge1xuICAgICAgdmFyIF9pbm5lck9wdGlvbnMyO1xuICAgICAgbGV0IGlubmVyT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICBpZiAoKF9pbm5lck9wdGlvbnMyID0gaW5uZXJPcHRpb25zKSAhPSBudWxsICYmIF9pbm5lck9wdGlvbnMyLnZhbHVlKSB7XG4gICAgICAgIGlubmVyT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGlubmVyT3B0aW9ucywge1xuICAgICAgICAgIHBhcmVudDogaW5uZXJPcHRpb25zLnZhbHVlLFxuICAgICAgICAgIHZhbHVlOiBpbm5lck9wdGlvbnMudmFsdWVba2V5XVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGJhc2UuZmllbGRzW2tleV0gPSB2YWx1ZS5kZXNjcmliZShpbm5lck9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZTtcbiAgfVxufVxuY3JlYXRlJDMucHJvdG90eXBlID0gT2JqZWN0U2NoZW1hLnByb3RvdHlwZTtcblxuZnVuY3Rpb24gY3JlYXRlJDIodHlwZSkge1xuICByZXR1cm4gbmV3IEFycmF5U2NoZW1hKHR5cGUpO1xufVxuY2xhc3MgQXJyYXlTY2hlbWEgZXh0ZW5kcyBTY2hlbWEge1xuICBjb25zdHJ1Y3Rvcih0eXBlKSB7XG4gICAgc3VwZXIoe1xuICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgIHNwZWM6IHtcbiAgICAgICAgdHlwZXM6IHR5cGVcbiAgICAgIH0sXG4gICAgICBjaGVjayh2KSB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHYpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gYHVuZGVmaW5lZGAgc3BlY2lmaWNhbGx5IG1lYW5zIHVuaW5pdGlhbGl6ZWQsIGFzIG9wcG9zZWQgdG8gXCJubyBzdWJ0eXBlXCJcbiAgICB0aGlzLmlubmVyVHlwZSA9IHZvaWQgMDtcbiAgICB0aGlzLmlubmVyVHlwZSA9IHR5cGU7XG4gIH1cbiAgX2Nhc3QoX3ZhbHVlLCBfb3B0cykge1xuICAgIGNvbnN0IHZhbHVlID0gc3VwZXIuX2Nhc3QoX3ZhbHVlLCBfb3B0cyk7XG5cbiAgICAvLyBzaG91bGQgaWdub3JlIG51bGxzIGhlcmVcbiAgICBpZiAoIXRoaXMuX3R5cGVDaGVjayh2YWx1ZSkgfHwgIXRoaXMuaW5uZXJUeXBlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGxldCBpc0NoYW5nZWQgPSBmYWxzZTtcbiAgICBjb25zdCBjYXN0QXJyYXkgPSB2YWx1ZS5tYXAoKHYsIGlkeCkgPT4ge1xuICAgICAgY29uc3QgY2FzdEVsZW1lbnQgPSB0aGlzLmlubmVyVHlwZS5jYXN0KHYsIE9iamVjdC5hc3NpZ24oe30sIF9vcHRzLCB7XG4gICAgICAgIHBhdGg6IGAke19vcHRzLnBhdGggfHwgJyd9WyR7aWR4fV1gXG4gICAgICB9KSk7XG4gICAgICBpZiAoY2FzdEVsZW1lbnQgIT09IHYpIHtcbiAgICAgICAgaXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYXN0RWxlbWVudDtcbiAgICB9KTtcbiAgICByZXR1cm4gaXNDaGFuZ2VkID8gY2FzdEFycmF5IDogdmFsdWU7XG4gIH1cbiAgX3ZhbGlkYXRlKF92YWx1ZSwgb3B0aW9ucyA9IHt9LCBwYW5pYywgbmV4dCkge1xuICAgIHZhciBfb3B0aW9ucyRyZWN1cnNpdmU7XG4gICAgLy8gbGV0IHN5bmMgPSBvcHRpb25zLnN5bmM7XG4gICAgLy8gbGV0IHBhdGggPSBvcHRpb25zLnBhdGg7XG4gICAgbGV0IGlubmVyVHlwZSA9IHRoaXMuaW5uZXJUeXBlO1xuICAgIC8vIGxldCBlbmRFYXJseSA9IG9wdGlvbnMuYWJvcnRFYXJseSA/PyB0aGlzLnNwZWMuYWJvcnRFYXJseTtcbiAgICBsZXQgcmVjdXJzaXZlID0gKF9vcHRpb25zJHJlY3Vyc2l2ZSA9IG9wdGlvbnMucmVjdXJzaXZlKSAhPSBudWxsID8gX29wdGlvbnMkcmVjdXJzaXZlIDogdGhpcy5zcGVjLnJlY3Vyc2l2ZTtcbiAgICBvcHRpb25zLm9yaWdpbmFsVmFsdWUgIT0gbnVsbCA/IG9wdGlvbnMub3JpZ2luYWxWYWx1ZSA6IF92YWx1ZTtcbiAgICBzdXBlci5fdmFsaWRhdGUoX3ZhbHVlLCBvcHRpb25zLCBwYW5pYywgKGFycmF5RXJyb3JzLCB2YWx1ZSkgPT4ge1xuICAgICAgdmFyIF9vcHRpb25zJG9yaWdpbmFsVmFsdTI7XG4gICAgICBpZiAoIXJlY3Vyc2l2ZSB8fCAhaW5uZXJUeXBlIHx8ICF0aGlzLl90eXBlQ2hlY2sodmFsdWUpKSB7XG4gICAgICAgIG5leHQoYXJyYXlFcnJvcnMsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyAjOTUwIEVuc3VyZSB0aGF0IHNwYXJzZSBhcnJheSBlbXB0eSBzbG90cyBhcmUgdmFsaWRhdGVkXG4gICAgICBsZXQgdGVzdHMgPSBuZXcgQXJyYXkodmFsdWUubGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB2YWx1ZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgdmFyIF9vcHRpb25zJG9yaWdpbmFsVmFsdTtcbiAgICAgICAgdGVzdHNbaW5kZXhdID0gaW5uZXJUeXBlLmFzTmVzdGVkVGVzdCh7XG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBwYXJlbnQ6IHZhbHVlLFxuICAgICAgICAgIHBhcmVudFBhdGg6IG9wdGlvbnMucGF0aCxcbiAgICAgICAgICBvcmlnaW5hbFBhcmVudDogKF9vcHRpb25zJG9yaWdpbmFsVmFsdSA9IG9wdGlvbnMub3JpZ2luYWxWYWx1ZSkgIT0gbnVsbCA/IF9vcHRpb25zJG9yaWdpbmFsVmFsdSA6IF92YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucnVuVGVzdHMoe1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgdGVzdHMsXG4gICAgICAgIG9yaWdpbmFsVmFsdWU6IChfb3B0aW9ucyRvcmlnaW5hbFZhbHUyID0gb3B0aW9ucy5vcmlnaW5hbFZhbHVlKSAhPSBudWxsID8gX29wdGlvbnMkb3JpZ2luYWxWYWx1MiA6IF92YWx1ZSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfSwgcGFuaWMsIGlubmVyVHlwZUVycm9ycyA9PiBuZXh0KGlubmVyVHlwZUVycm9ycy5jb25jYXQoYXJyYXlFcnJvcnMpLCB2YWx1ZSkpO1xuICAgIH0pO1xuICB9XG4gIGNsb25lKHNwZWMpIHtcbiAgICBjb25zdCBuZXh0ID0gc3VwZXIuY2xvbmUoc3BlYyk7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciByZWFkb25seVxuICAgIG5leHQuaW5uZXJUeXBlID0gdGhpcy5pbm5lclR5cGU7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cblxuICAvKiogUGFyc2UgYW4gaW5wdXQgSlNPTiBzdHJpbmcgdG8gYW4gb2JqZWN0ICovXG4gIGpzb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHBhcnNlSnNvbik7XG4gIH1cbiAgY29uY2F0KHNjaGVtYSkge1xuICAgIGxldCBuZXh0ID0gc3VwZXIuY29uY2F0KHNjaGVtYSk7XG5cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHJlYWRvbmx5XG4gICAgbmV4dC5pbm5lclR5cGUgPSB0aGlzLmlubmVyVHlwZTtcbiAgICBpZiAoc2NoZW1hLmlubmVyVHlwZSlcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgcmVhZG9ubHlcbiAgICAgIG5leHQuaW5uZXJUeXBlID0gbmV4dC5pbm5lclR5cGUgP1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBMYXp5IGRvZXNuJ3QgaGF2ZSBjb25jYXQgYW5kIHdpbGwgYnJlYWtcbiAgICAgIG5leHQuaW5uZXJUeXBlLmNvbmNhdChzY2hlbWEuaW5uZXJUeXBlKSA6IHNjaGVtYS5pbm5lclR5cGU7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgb2Yoc2NoZW1hKSB7XG4gICAgLy8gRklYTUU6IHRoaXMgc2hvdWxkIHJldHVybiBhIG5ldyBpbnN0YW5jZSBvZiBhcnJheSB3aXRob3V0IHRoZSBkZWZhdWx0IHRvIGJlXG4gICAgbGV0IG5leHQgPSB0aGlzLmNsb25lKCk7XG4gICAgaWYgKCFpc1NjaGVtYShzY2hlbWEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdgYXJyYXkub2YoKWAgc3ViLXNjaGVtYSBtdXN0IGJlIGEgdmFsaWQgeXVwIHNjaGVtYSBub3Q6ICcgKyBwcmludFZhbHVlKHNjaGVtYSkpO1xuXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciByZWFkb25seVxuICAgIG5leHQuaW5uZXJUeXBlID0gc2NoZW1hO1xuICAgIG5leHQuc3BlYyA9IE9iamVjdC5hc3NpZ24oe30sIG5leHQuc3BlYywge1xuICAgICAgdHlwZXM6IHNjaGVtYVxuICAgIH0pO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIGxlbmd0aChsZW5ndGgsIG1lc3NhZ2UgPSBhcnJheS5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAnbGVuZ3RoJyxcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBsZW5ndGhcbiAgICAgIH0sXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoID09PSB0aGlzLnJlc29sdmUobGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBtaW4obWluLCBtZXNzYWdlKSB7XG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UgfHwgYXJyYXkubWluO1xuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdtaW4nLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIG1pblxuICAgICAgfSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICAvLyBGSVhNRSh0cyk6IEFycmF5PHR5cGVvZiBUPlxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoID49IHRoaXMucmVzb2x2ZShtaW4pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG1heChtYXgsIG1lc3NhZ2UpIHtcbiAgICBtZXNzYWdlID0gbWVzc2FnZSB8fCBhcnJheS5tYXg7XG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ21heCcsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbWF4XG4gICAgICB9LFxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA8PSB0aGlzLnJlc29sdmUobWF4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBlbnN1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmYXVsdCgoKSA9PiBbXSkudHJhbnNmb3JtKCh2YWwsIG9yaWdpbmFsKSA9PiB7XG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIHJldHVybiBgbnVsbGAgZm9yIG51bGxhYmxlIHNjaGVtYVxuICAgICAgaWYgKHRoaXMuX3R5cGVDaGVjayh2YWwpKSByZXR1cm4gdmFsO1xuICAgICAgcmV0dXJuIG9yaWdpbmFsID09IG51bGwgPyBbXSA6IFtdLmNvbmNhdChvcmlnaW5hbCk7XG4gICAgfSk7XG4gIH1cbiAgY29tcGFjdChyZWplY3Rvcikge1xuICAgIGxldCByZWplY3QgPSAhcmVqZWN0b3IgPyB2ID0+ICEhdiA6ICh2LCBpLCBhKSA9PiAhcmVqZWN0b3IodiwgaSwgYSk7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHZhbHVlcyA9PiB2YWx1ZXMgIT0gbnVsbCA/IHZhbHVlcy5maWx0ZXIocmVqZWN0KSA6IHZhbHVlcyk7XG4gIH1cbiAgZGVzY3JpYmUob3B0aW9ucykge1xuICAgIGNvbnN0IG5leHQgPSAob3B0aW9ucyA/IHRoaXMucmVzb2x2ZShvcHRpb25zKSA6IHRoaXMpLmNsb25lKCk7XG4gICAgY29uc3QgYmFzZSA9IHN1cGVyLmRlc2NyaWJlKG9wdGlvbnMpO1xuICAgIGlmIChuZXh0LmlubmVyVHlwZSkge1xuICAgICAgdmFyIF9pbm5lck9wdGlvbnM7XG4gICAgICBsZXQgaW5uZXJPcHRpb25zID0gb3B0aW9ucztcbiAgICAgIGlmICgoX2lubmVyT3B0aW9ucyA9IGlubmVyT3B0aW9ucykgIT0gbnVsbCAmJiBfaW5uZXJPcHRpb25zLnZhbHVlKSB7XG4gICAgICAgIGlubmVyT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGlubmVyT3B0aW9ucywge1xuICAgICAgICAgIHBhcmVudDogaW5uZXJPcHRpb25zLnZhbHVlLFxuICAgICAgICAgIHZhbHVlOiBpbm5lck9wdGlvbnMudmFsdWVbMF1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBiYXNlLmlubmVyVHlwZSA9IG5leHQuaW5uZXJUeXBlLmRlc2NyaWJlKGlubmVyT3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBiYXNlO1xuICB9XG59XG5jcmVhdGUkMi5wcm90b3R5cGUgPSBBcnJheVNjaGVtYS5wcm90b3R5cGU7XG5cbi8vIEB0cy1pZ25vcmVcbmZ1bmN0aW9uIGNyZWF0ZSQxKHNjaGVtYXMpIHtcbiAgcmV0dXJuIG5ldyBUdXBsZVNjaGVtYShzY2hlbWFzKTtcbn1cbmNsYXNzIFR1cGxlU2NoZW1hIGV4dGVuZHMgU2NoZW1hIHtcbiAgY29uc3RydWN0b3Ioc2NoZW1hcykge1xuICAgIHN1cGVyKHtcbiAgICAgIHR5cGU6ICd0dXBsZScsXG4gICAgICBzcGVjOiB7XG4gICAgICAgIHR5cGVzOiBzY2hlbWFzXG4gICAgICB9LFxuICAgICAgY2hlY2sodikge1xuICAgICAgICBjb25zdCB0eXBlcyA9IHRoaXMuc3BlYy50eXBlcztcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodikgJiYgdi5sZW5ndGggPT09IHR5cGVzLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLndpdGhNdXRhdGlvbigoKSA9PiB7XG4gICAgICB0aGlzLnR5cGVFcnJvcih0dXBsZS5ub3RUeXBlKTtcbiAgICB9KTtcbiAgfVxuICBfY2FzdChpbnB1dFZhbHVlLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZXNcbiAgICB9ID0gdGhpcy5zcGVjO1xuICAgIGNvbnN0IHZhbHVlID0gc3VwZXIuX2Nhc3QoaW5wdXRWYWx1ZSwgb3B0aW9ucyk7XG4gICAgaWYgKCF0aGlzLl90eXBlQ2hlY2sodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGxldCBpc0NoYW5nZWQgPSBmYWxzZTtcbiAgICBjb25zdCBjYXN0QXJyYXkgPSB0eXBlcy5tYXAoKHR5cGUsIGlkeCkgPT4ge1xuICAgICAgY29uc3QgY2FzdEVsZW1lbnQgPSB0eXBlLmNhc3QodmFsdWVbaWR4XSwgT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgICBwYXRoOiBgJHtvcHRpb25zLnBhdGggfHwgJyd9WyR7aWR4fV1gXG4gICAgICB9KSk7XG4gICAgICBpZiAoY2FzdEVsZW1lbnQgIT09IHZhbHVlW2lkeF0pIGlzQ2hhbmdlZCA9IHRydWU7XG4gICAgICByZXR1cm4gY2FzdEVsZW1lbnQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIGlzQ2hhbmdlZCA/IGNhc3RBcnJheSA6IHZhbHVlO1xuICB9XG4gIF92YWxpZGF0ZShfdmFsdWUsIG9wdGlvbnMgPSB7fSwgcGFuaWMsIG5leHQpIHtcbiAgICBsZXQgaXRlbVR5cGVzID0gdGhpcy5zcGVjLnR5cGVzO1xuICAgIHN1cGVyLl92YWxpZGF0ZShfdmFsdWUsIG9wdGlvbnMsIHBhbmljLCAodHVwbGVFcnJvcnMsIHZhbHVlKSA9PiB7XG4gICAgICB2YXIgX29wdGlvbnMkb3JpZ2luYWxWYWx1MjtcbiAgICAgIC8vIGludGVudGlvbmFsbHkgbm90IHJlc3BlY3RpbmcgcmVjdXJzaXZlXG4gICAgICBpZiAoIXRoaXMuX3R5cGVDaGVjayh2YWx1ZSkpIHtcbiAgICAgICAgbmV4dCh0dXBsZUVycm9ycywgdmFsdWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgdGVzdHMgPSBbXTtcbiAgICAgIGZvciAobGV0IFtpbmRleCwgaXRlbVNjaGVtYV0gb2YgaXRlbVR5cGVzLmVudHJpZXMoKSkge1xuICAgICAgICB2YXIgX29wdGlvbnMkb3JpZ2luYWxWYWx1O1xuICAgICAgICB0ZXN0c1tpbmRleF0gPSBpdGVtU2NoZW1hLmFzTmVzdGVkVGVzdCh7XG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBwYXJlbnQ6IHZhbHVlLFxuICAgICAgICAgIHBhcmVudFBhdGg6IG9wdGlvbnMucGF0aCxcbiAgICAgICAgICBvcmlnaW5hbFBhcmVudDogKF9vcHRpb25zJG9yaWdpbmFsVmFsdSA9IG9wdGlvbnMub3JpZ2luYWxWYWx1ZSkgIT0gbnVsbCA/IF9vcHRpb25zJG9yaWdpbmFsVmFsdSA6IF92YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucnVuVGVzdHMoe1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgdGVzdHMsXG4gICAgICAgIG9yaWdpbmFsVmFsdWU6IChfb3B0aW9ucyRvcmlnaW5hbFZhbHUyID0gb3B0aW9ucy5vcmlnaW5hbFZhbHVlKSAhPSBudWxsID8gX29wdGlvbnMkb3JpZ2luYWxWYWx1MiA6IF92YWx1ZSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfSwgcGFuaWMsIGlubmVyVHlwZUVycm9ycyA9PiBuZXh0KGlubmVyVHlwZUVycm9ycy5jb25jYXQodHVwbGVFcnJvcnMpLCB2YWx1ZSkpO1xuICAgIH0pO1xuICB9XG4gIGRlc2NyaWJlKG9wdGlvbnMpIHtcbiAgICBjb25zdCBuZXh0ID0gKG9wdGlvbnMgPyB0aGlzLnJlc29sdmUob3B0aW9ucykgOiB0aGlzKS5jbG9uZSgpO1xuICAgIGNvbnN0IGJhc2UgPSBzdXBlci5kZXNjcmliZShvcHRpb25zKTtcbiAgICBiYXNlLmlubmVyVHlwZSA9IG5leHQuc3BlYy50eXBlcy5tYXAoKHNjaGVtYSwgaW5kZXgpID0+IHtcbiAgICAgIHZhciBfaW5uZXJPcHRpb25zO1xuICAgICAgbGV0IGlubmVyT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICBpZiAoKF9pbm5lck9wdGlvbnMgPSBpbm5lck9wdGlvbnMpICE9IG51bGwgJiYgX2lubmVyT3B0aW9ucy52YWx1ZSkge1xuICAgICAgICBpbm5lck9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBpbm5lck9wdGlvbnMsIHtcbiAgICAgICAgICBwYXJlbnQ6IGlubmVyT3B0aW9ucy52YWx1ZSxcbiAgICAgICAgICB2YWx1ZTogaW5uZXJPcHRpb25zLnZhbHVlW2luZGV4XVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWEuZGVzY3JpYmUoaW5uZXJPcHRpb25zKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYmFzZTtcbiAgfVxufVxuY3JlYXRlJDEucHJvdG90eXBlID0gVHVwbGVTY2hlbWEucHJvdG90eXBlO1xuXG5mdW5jdGlvbiBjcmVhdGUoYnVpbGRlcikge1xuICByZXR1cm4gbmV3IExhenkoYnVpbGRlcik7XG59XG5jbGFzcyBMYXp5IHtcbiAgY29uc3RydWN0b3IoYnVpbGRlcikge1xuICAgIHRoaXMudHlwZSA9ICdsYXp5JztcbiAgICB0aGlzLl9faXNZdXBTY2hlbWFfXyA9IHRydWU7XG4gICAgdGhpcy5zcGVjID0gdm9pZCAwO1xuICAgIHRoaXMuX3Jlc29sdmUgPSAodmFsdWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgbGV0IHNjaGVtYSA9IHRoaXMuYnVpbGRlcih2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICBpZiAoIWlzU2NoZW1hKHNjaGVtYSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xhenkoKSBmdW5jdGlvbnMgbXVzdCByZXR1cm4gYSB2YWxpZCBzY2hlbWEnKTtcbiAgICAgIGlmICh0aGlzLnNwZWMub3B0aW9uYWwpIHNjaGVtYSA9IHNjaGVtYS5vcHRpb25hbCgpO1xuICAgICAgcmV0dXJuIHNjaGVtYS5yZXNvbHZlKG9wdGlvbnMpO1xuICAgIH07XG4gICAgdGhpcy5idWlsZGVyID0gYnVpbGRlcjtcbiAgICB0aGlzLnNwZWMgPSB7XG4gICAgICBtZXRhOiB1bmRlZmluZWQsXG4gICAgICBvcHRpb25hbDogZmFsc2VcbiAgICB9O1xuICB9XG4gIGNsb25lKHNwZWMpIHtcbiAgICBjb25zdCBuZXh0ID0gbmV3IExhenkodGhpcy5idWlsZGVyKTtcbiAgICBuZXh0LnNwZWMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnNwZWMsIHNwZWMpO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIG9wdGlvbmFsaXR5KG9wdGlvbmFsKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuY2xvbmUoe1xuICAgICAgb3B0aW9uYWxcbiAgICB9KTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICBvcHRpb25hbCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25hbGl0eSh0cnVlKTtcbiAgfVxuICByZXNvbHZlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZShvcHRpb25zLnZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBjYXN0KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmUodmFsdWUsIG9wdGlvbnMpLmNhc3QodmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIGFzTmVzdGVkVGVzdChjb25maWcpIHtcbiAgICBsZXQge1xuICAgICAga2V5LFxuICAgICAgaW5kZXgsXG4gICAgICBwYXJlbnQsXG4gICAgICBvcHRpb25zXG4gICAgfSA9IGNvbmZpZztcbiAgICBsZXQgdmFsdWUgPSBwYXJlbnRbaW5kZXggIT0gbnVsbCA/IGluZGV4IDoga2V5XTtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZSh2YWx1ZSwgT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgdmFsdWUsXG4gICAgICBwYXJlbnRcbiAgICB9KSkuYXNOZXN0ZWRUZXN0KGNvbmZpZyk7XG4gIH1cbiAgdmFsaWRhdGUodmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZSh2YWx1ZSwgb3B0aW9ucykudmFsaWRhdGUodmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHZhbGlkYXRlU3luYyh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKHZhbHVlLCBvcHRpb25zKS52YWxpZGF0ZVN5bmModmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHZhbGlkYXRlQXQocGF0aCwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZSh2YWx1ZSwgb3B0aW9ucykudmFsaWRhdGVBdChwYXRoLCB2YWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgdmFsaWRhdGVTeW5jQXQocGF0aCwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZSh2YWx1ZSwgb3B0aW9ucykudmFsaWRhdGVTeW5jQXQocGF0aCwgdmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIGlzVmFsaWQodmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZSh2YWx1ZSwgb3B0aW9ucykuaXNWYWxpZCh2YWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgaXNWYWxpZFN5bmModmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZSh2YWx1ZSwgb3B0aW9ucykuaXNWYWxpZFN5bmModmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIGRlc2NyaWJlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucyA/IHRoaXMucmVzb2x2ZShvcHRpb25zKS5kZXNjcmliZShvcHRpb25zKSA6IHtcbiAgICAgIHR5cGU6ICdsYXp5JyxcbiAgICAgIG1ldGE6IHRoaXMuc3BlYy5tZXRhLFxuICAgICAgbGFiZWw6IHVuZGVmaW5lZFxuICAgIH07XG4gIH1cbiAgbWV0YSguLi5hcmdzKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5zcGVjLm1ldGE7XG4gICAgbGV0IG5leHQgPSB0aGlzLmNsb25lKCk7XG4gICAgbmV4dC5zcGVjLm1ldGEgPSBPYmplY3QuYXNzaWduKG5leHQuc3BlYy5tZXRhIHx8IHt9LCBhcmdzWzBdKTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRMb2NhbGUoY3VzdG9tKSB7XG4gIE9iamVjdC5rZXlzKGN1c3RvbSkuZm9yRWFjaCh0eXBlID0+IHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgT2JqZWN0LmtleXMoY3VzdG9tW3R5cGVdKS5mb3JFYWNoKG1ldGhvZCA9PiB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBsb2NhbGVbdHlwZV1bbWV0aG9kXSA9IGN1c3RvbVt0eXBlXVttZXRob2RdO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkTWV0aG9kKHNjaGVtYVR5cGUsIG5hbWUsIGZuKSB7XG4gIGlmICghc2NoZW1hVHlwZSB8fCAhaXNTY2hlbWEoc2NoZW1hVHlwZS5wcm90b3R5cGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwcm92aWRlIGEgeXVwIHNjaGVtYSBjb25zdHJ1Y3RvciBmdW5jdGlvbicpO1xuICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIE1ldGhvZCBuYW1lIG11c3QgYmUgcHJvdmlkZWQnKTtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IFR5cGVFcnJvcignTWV0aG9kIGZ1bmN0aW9uIG11c3QgYmUgcHJvdmlkZWQnKTtcbiAgc2NoZW1hVHlwZS5wcm90b3R5cGVbbmFtZV0gPSBmbjtcbn1cblxuZXhwb3J0IHsgQXJyYXlTY2hlbWEsIEJvb2xlYW5TY2hlbWEsIERhdGVTY2hlbWEsIE1peGVkU2NoZW1hLCBOdW1iZXJTY2hlbWEsIE9iamVjdFNjaGVtYSwgU2NoZW1hLCBTdHJpbmdTY2hlbWEsIFR1cGxlU2NoZW1hLCBWYWxpZGF0aW9uRXJyb3IsIGFkZE1ldGhvZCwgY3JlYXRlJDIgYXMgYXJyYXksIGNyZWF0ZSQ3IGFzIGJvb2wsIGNyZWF0ZSQ3IGFzIGJvb2xlYW4sIGNyZWF0ZSQ0IGFzIGRhdGUsIGxvY2FsZSBhcyBkZWZhdWx0TG9jYWxlLCBnZXRJbiwgaXNTY2hlbWEsIGNyZWF0ZSBhcyBsYXp5LCBjcmVhdGUkOCBhcyBtaXhlZCwgY3JlYXRlJDUgYXMgbnVtYmVyLCBjcmVhdGUkMyBhcyBvYmplY3QsIHByaW50VmFsdWUsIHJlYWNoLCBjcmVhdGUkOSBhcyByZWYsIHNldExvY2FsZSwgY3JlYXRlJDYgYXMgc3RyaW5nLCBjcmVhdGUkMSBhcyB0dXBsZSB9O1xuIl0sIm5hbWVzIjpbImdldHRlciIsImZvckVhY2giLCJzcGxpdCIsIm5vcm1hbGl6ZVBhdGgiLCJqb2luIiwiY2FtZWxDYXNlIiwic25ha2VDYXNlIiwidG9wb3NvcnQiLCJ0b1N0cmluZyIsIk9iamVjdCIsInByb3RvdHlwZSIsImVycm9yVG9TdHJpbmciLCJFcnJvciIsInJlZ0V4cFRvU3RyaW5nIiwiUmVnRXhwIiwic3ltYm9sVG9TdHJpbmciLCJTeW1ib2wiLCJTWU1CT0xfUkVHRVhQIiwicHJpbnROdW1iZXIiLCJ2YWwiLCJpc05lZ2F0aXZlWmVybyIsInByaW50U2ltcGxlVmFsdWUiLCJxdW90ZVN0cmluZ3MiLCJ0eXBlT2YiLCJuYW1lIiwiY2FsbCIsInJlcGxhY2UiLCJ0YWciLCJzbGljZSIsImlzTmFOIiwiZ2V0VGltZSIsInRvSVNPU3RyaW5nIiwicHJpbnRWYWx1ZSIsInZhbHVlIiwicmVzdWx0IiwiSlNPTiIsInN0cmluZ2lmeSIsImtleSIsInRvQXJyYXkiLCJjb25jYXQiLCJfU3ltYm9sJHRvU3RyaW5nVGFnIiwiX1N5bWJvbCRoYXNJbnN0YW5jZSIsIl9TeW1ib2wkdG9TdHJpbmdUYWcyIiwic3RyUmVnIiwidG9TdHJpbmdUYWciLCJWYWxpZGF0aW9uRXJyb3JOb1N0YWNrIiwiY29uc3RydWN0b3IiLCJlcnJvck9yRXJyb3JzIiwiZmllbGQiLCJ0eXBlIiwibWVzc2FnZSIsInBhdGgiLCJwYXJhbXMiLCJlcnJvcnMiLCJpbm5lciIsImVyciIsIlZhbGlkYXRpb25FcnJvciIsImlzRXJyb3IiLCJwdXNoIiwiaW5uZXJFcnJvcnMiLCJsZW5ndGgiLCJoYXNJbnN0YW5jZSIsImZvcm1hdEVycm9yIiwibGFiZWwiLCJhc3NpZ24iLCJfIiwiZGlzYWJsZVN0YWNrIiwiZXJyb3JOb1N0YWNrIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJpbnN0IiwibWl4ZWQiLCJkZWZhdWx0IiwicmVxdWlyZWQiLCJkZWZpbmVkIiwibm90TnVsbCIsIm9uZU9mIiwibm90T25lT2YiLCJub3RUeXBlIiwib3JpZ2luYWxWYWx1ZSIsImNhc3RNc2ciLCJzdHJpbmciLCJtaW4iLCJtYXgiLCJtYXRjaGVzIiwiZW1haWwiLCJ1cmwiLCJ1dWlkIiwiZGF0ZXRpbWUiLCJkYXRldGltZV9wcmVjaXNpb24iLCJkYXRldGltZV9vZmZzZXQiLCJ0cmltIiwibG93ZXJjYXNlIiwidXBwZXJjYXNlIiwibnVtYmVyIiwibGVzc1RoYW4iLCJtb3JlVGhhbiIsInBvc2l0aXZlIiwibmVnYXRpdmUiLCJpbnRlZ2VyIiwiZGF0ZSIsImJvb2xlYW4iLCJpc1ZhbHVlIiwib2JqZWN0Iiwibm9Vbmtub3duIiwiYXJyYXkiLCJ0dXBsZSIsInNwZWMiLCJ0eXBlTGVuIiwidHlwZXMiLCJBcnJheSIsImlzQXJyYXkiLCJsb2NhbGUiLCJjcmVhdGUiLCJpc1NjaGVtYSIsIm9iaiIsIl9faXNZdXBTY2hlbWFfXyIsIkNvbmRpdGlvbiIsImZyb21PcHRpb25zIiwicmVmcyIsImNvbmZpZyIsInRoZW4iLCJvdGhlcndpc2UiLCJUeXBlRXJyb3IiLCJpcyIsImNoZWNrIiwidmFsdWVzIiwiZXZlcnkiLCJzY2hlbWEiLCJfYnJhbmNoIiwiYnJhbmNoIiwiYnVpbGRlciIsImZuIiwicmVzb2x2ZSIsImJhc2UiLCJvcHRpb25zIiwibWFwIiwicmVmIiwiZ2V0VmFsdWUiLCJwYXJlbnQiLCJjb250ZXh0IiwidW5kZWZpbmVkIiwicHJlZml4ZXMiLCJjcmVhdGUkOSIsIlJlZmVyZW5jZSIsImlzQ29udGV4dCIsImlzU2libGluZyIsInByZWZpeCIsImNhc3QiLCJkZXNjcmliZSIsImlzUmVmIiwiX19pc1l1cFJlZiIsImlzQWJzZW50IiwiY3JlYXRlVmFsaWRhdGlvbiIsInZhbGlkYXRlIiwicGFuaWMiLCJuZXh0IiwidGVzdCIsInNraXBBYnNlbnQiLCJhYm9ydEVhcmx5IiwiZGlzYWJsZVN0YWNrVHJhY2UiLCJpdGVtIiwiY3JlYXRlRXJyb3IiLCJvdmVycmlkZXMiLCJuZXh0UGFyYW1zIiwia2V5cyIsImVycm9yIiwiaW52YWxpZCIsImN0eCIsImZyb20iLCJoYW5kbGVSZXN1bHQiLCJ2YWxpZE9yRXJyb3IiLCJoYW5kbGVFcnJvciIsInNob3VsZFNraXAiLCJfcmVzdWx0Iiwic3luYyIsIlByb21pc2UiLCJPUFRJT05TIiwiZ2V0SW4iLCJsYXN0UGFydCIsImxhc3RQYXJ0RGVidWciLCJwYXJlbnRQYXRoIiwiX3BhcnQiLCJpc0JyYWNrZXQiLCJwYXJ0IiwiaXNUdXBsZSIsImlkeCIsInBhcnNlSW50IiwiaW5uZXJUeXBlIiwiZmllbGRzIiwicmVhY2giLCJSZWZlcmVuY2VTZXQiLCJTZXQiLCJkZXNjcmlwdGlvbiIsInJlc29sdmVBbGwiLCJjbG9uZSIsIm1lcmdlIiwibmV3SXRlbXMiLCJyZW1vdmVJdGVtcyIsImFkZCIsImRlbGV0ZSIsInNyYyIsInNlZW4iLCJNYXAiLCJoYXMiLCJnZXQiLCJjb3B5IiwiRGF0ZSIsInNldCIsImkiLCJrIiwidiIsImVudHJpZXMiLCJTY2hlbWEiLCJkZXBzIiwidGVzdHMiLCJ0cmFuc2Zvcm1zIiwiY29uZGl0aW9ucyIsIl9tdXRhdGUiLCJpbnRlcm5hbFRlc3RzIiwiX3doaXRlbGlzdCIsIl9ibGFja2xpc3QiLCJleGNsdXNpdmVUZXN0cyIsIl90eXBlQ2hlY2siLCJ3aXRoTXV0YXRpb24iLCJ0eXBlRXJyb3IiLCJzdHJpcCIsInN0cmljdCIsInJlY3Vyc2l2ZSIsIm51bGxhYmxlIiwib3B0aW9uYWwiLCJjb2VyY2UiLCJzIiwibm9uTnVsbGFibGUiLCJfdHlwZSIsImdldFByb3RvdHlwZU9mIiwibWV0YSIsImFyZ3MiLCJiZWZvcmUiLCJjb21iaW5lZCIsIm1lcmdlZFNwZWMiLCJpc1R5cGUiLCJyZWR1Y2UiLCJwcmV2U2NoZW1hIiwiY29uZGl0aW9uIiwicmVzb2x2ZU9wdGlvbnMiLCJfb3B0aW9ucyRzdHJpY3QiLCJfb3B0aW9ucyRhYm9ydEVhcmx5IiwiX29wdGlvbnMkcmVjdXJzaXZlIiwiX29wdGlvbnMkZGlzYWJsZVN0YWNrIiwicmVzb2x2ZWRTY2hlbWEiLCJhbGxvd09wdGlvbmFsaXR5IiwiYXNzZXJ0IiwiX2Nhc3QiLCJmb3JtYXR0ZWRWYWx1ZSIsImZvcm1hdHRlZFJlc3VsdCIsInJhd1ZhbHVlIiwicHJldlZhbHVlIiwiZ2V0RGVmYXVsdCIsIl92YWxpZGF0ZSIsIl92YWx1ZSIsImluaXRpYWxUZXN0cyIsInJ1blRlc3RzIiwiaW5pdGlhbEVycm9ycyIsInJ1bk9wdGlvbnMiLCJmaXJlZCIsInBhbmljT25jZSIsImFyZyIsIm5leHRPbmNlIiwiY291bnQiLCJuZXN0ZWRFcnJvcnMiLCJmaW5pc2hUZXN0UnVuIiwiYXNOZXN0ZWRUZXN0IiwiaW5kZXgiLCJvcmlnaW5hbFBhcmVudCIsImlzSW5kZXgiLCJ0ZXN0T3B0aW9ucyIsImluY2x1ZGVzIiwiX29wdGlvbnMkZGlzYWJsZVN0YWNrMiIsInJlamVjdCIsInBhcnNlZCIsInZhbGlkYXRlZCIsInZhbGlkYXRlU3luYyIsIl9vcHRpb25zJGRpc2FibGVTdGFjazMiLCJpc1ZhbGlkIiwiaXNWYWxpZFN5bmMiLCJfZ2V0RGVmYXVsdCIsImRlZmF1bHRWYWx1ZSIsImRlZiIsImFyZ3VtZW50cyIsImlzU3RyaWN0IiwibnVsbGFiaWxpdHkiLCJvcHRpb25hbGl0eSIsIm5vdFJlcXVpcmVkIiwidHJhbnNmb3JtIiwib3B0cyIsImlzRXhjbHVzaXZlIiwiZXhjbHVzaXZlIiwiZmlsdGVyIiwid2hlbiIsImRlcCIsImVudW1zIiwid2hpdGVMaXN0IiwidmFsaWRzIiwicmVzb2x2ZWQiLCJibGFja2xpc3QiLCJpbnZhbGlkcyIsIm4iLCJsaXN0IiwiZmluZEluZGV4IiwiYyIsIm1ldGhvZCIsImFsaWFzIiwicmV0dXJuc1RydWUiLCJjcmVhdGUkOCIsIk1peGVkU2NoZW1hIiwiY3JlYXRlJDciLCJCb29sZWFuU2NoZW1hIiwiQm9vbGVhbiIsInZhbHVlT2YiLCJfcmF3IiwiU3RyaW5nIiwiaXNUcnVlIiwiaXNGYWxzZSIsIm1zZyIsImlzb1JlZyIsInBhcnNlSXNvRGF0ZSIsInN0cnVjdCIsInBhcnNlRGF0ZVN0cnVjdCIsInBhcnNlIiwiTnVtYmVyIiwiTmFOIiwieiIsInBsdXNNaW51cyIsInllYXIiLCJtb250aCIsImRheSIsImhvdXIiLCJtaW51dGUiLCJzZWNvbmQiLCJtaWxsaXNlY29uZCIsInRvdGFsTWludXRlc09mZnNldCIsImhvdXJPZmZzZXQiLCJtaW51dGVPZmZzZXQiLCJVVEMiLCJfcmVnZXhSZXN1bHQkNyRsZW5ndGgiLCJfcmVnZXhSZXN1bHQkIiwicmVnZXhSZXN1bHQiLCJleGVjIiwidG9OdW1iZXIiLCJzdWJzdHJpbmciLCJwcmVjaXNpb24iLCJzdHIiLCJyRW1haWwiLCJyVXJsIiwiclVVSUQiLCJ5ZWFyTW9udGhEYXkiLCJob3VyTWludXRlU2Vjb25kIiwiek9yT2Zmc2V0Iiwicklzb0RhdGVUaW1lIiwiaXNUcmltbWVkIiwib2JqU3RyaW5nVGFnIiwiY3JlYXRlJDYiLCJTdHJpbmdTY2hlbWEiLCJzdHJWYWx1ZSIsInQiLCJyZWdleCIsImV4Y2x1ZGVFbXB0eVN0cmluZyIsInNlYXJjaCIsImFsbG93T2Zmc2V0IiwiZW5zdXJlIiwidG9Mb3dlckNhc2UiLCJ0b1VwcGVyQ2FzZSIsImlzTmFOJDEiLCJjcmVhdGUkNSIsIk51bWJlclNjaGVtYSIsInBhcnNlRmxvYXQiLCJsZXNzIiwibW9yZSIsImlzSW50ZWdlciIsInRydW5jYXRlIiwicm91bmQiLCJfbWV0aG9kIiwiYXZhaWwiLCJpbmRleE9mIiwiTWF0aCIsImludmFsaWREYXRlIiwiaXNEYXRlIiwiY3JlYXRlJDQiLCJEYXRlU2NoZW1hIiwiSU5WQUxJRF9EQVRFIiwicHJlcGFyZVBhcmFtIiwicGFyYW0iLCJsaW1pdCIsInNvcnRGaWVsZHMiLCJleGNsdWRlZEVkZ2VzIiwiZWRnZXMiLCJub2RlcyIsImV4Y2x1ZGVzIiwiYSIsImIiLCJhZGROb2RlIiwiZGVwUGF0aCIsIm5vZGUiLCJyZXZlcnNlIiwiYXJyIiwiSW5maW5pdHkiLCJzb21lIiwiaWkiLCJfZXJyJHBhdGgiLCJzb3J0QnlLZXlPcmRlciIsInBhcnNlSnNvbiIsImRlZXBQYXJ0aWFsIiwicGFydGlhbCIsImZpZWxkU2NoZW1hIiwic2V0RmllbGRzIiwibmV4dEFycmF5IiwiZGVlcEhhcyIsInAiLCJsYXN0IiwicG9wIiwiaXNPYmplY3QiLCJ1bmtub3duIiwia25vd24iLCJkZWZhdWx0U29ydCIsImNyZWF0ZSQzIiwiT2JqZWN0U2NoZW1hIiwiX3NvcnRFcnJvcnMiLCJfbm9kZXMiLCJfZXhjbHVkZWRFZGdlcyIsInNoYXBlIiwiX29wdGlvbnMkc3RyaXBVbmtub3duIiwic3RyaXBVbmtub3duIiwicHJvcHMiLCJpbnRlcm1lZGlhdGVWYWx1ZSIsImlubmVyT3B0aW9ucyIsIl9fdmFsaWRhdGluZyIsImlzQ2hhbmdlZCIsInByb3AiLCJleGlzdHMiLCJmaWVsZFZhbHVlIiwiaW5wdXRWYWx1ZSIsImZpZWxkU3BlYyIsIm9iamVjdEVycm9ycyIsImZpZWxkRXJyb3JzIiwic29ydCIsIm5leHRGaWVsZHMiLCJzY2hlbWFPclJlZiIsInRhcmdldCIsImRmdCIsIl9pbm5lck9wdGlvbnMiLCJhZGRpdGlvbnMiLCJGdW5jdGlvbiIsInBpY2siLCJwaWNrZWQiLCJvbWl0IiwicmVtYWluaW5nIiwidG8iLCJmcm9tR2V0dGVyIiwibmV3T2JqIiwianNvbiIsIm5vQWxsb3ciLCJ1bmtub3duS2V5cyIsImFsbG93IiwidHJhbnNmb3JtS2V5cyIsImNvbnN0YW50Q2FzZSIsIl9pbm5lck9wdGlvbnMyIiwiY3JlYXRlJDIiLCJBcnJheVNjaGVtYSIsIl9vcHRzIiwiY2FzdEFycmF5IiwiY2FzdEVsZW1lbnQiLCJhcnJheUVycm9ycyIsIl9vcHRpb25zJG9yaWdpbmFsVmFsdTIiLCJfb3B0aW9ucyRvcmlnaW5hbFZhbHUiLCJpbm5lclR5cGVFcnJvcnMiLCJvZiIsIm9yaWdpbmFsIiwiY29tcGFjdCIsInJlamVjdG9yIiwiY3JlYXRlJDEiLCJzY2hlbWFzIiwiVHVwbGVTY2hlbWEiLCJpdGVtVHlwZXMiLCJ0dXBsZUVycm9ycyIsIml0ZW1TY2hlbWEiLCJMYXp5IiwiX3Jlc29sdmUiLCJ2YWxpZGF0ZUF0IiwidmFsaWRhdGVTeW5jQXQiLCJzZXRMb2NhbGUiLCJjdXN0b20iLCJhZGRNZXRob2QiLCJzY2hlbWFUeXBlIiwiYm9vbCIsImRlZmF1bHRMb2NhbGUiLCJsYXp5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/yup/index.esm.js\n");

/***/ })

};
;